Disassembly Listing for Segway 19.07.15
Generated From:
C:/MCprojects/Segway/Segway/dist/default/debug/Segway.debug.elf
2015-10-16 23:34:41

---  C:/MCprojects/Segway/Segway/main.c  ----------------------------------------------------------------
1:                 /**********************************************************************c
2:                 * Author: Marcin Dec
3:                 * Date: 31.01.2015
4:                 * FileName:        main.c
5:                 * Dependencies:    Header (.h) files if applicable, see below
6:                 * Processor:       dsPIC30F6013A
7:                 * Compiler:        MPLAB® C30 v3.00 or higher
8:                 *
9:                 ************************************************************************/
10:                
11:                #include <p30f6013A.h>
12:                #include "ADC.h"
13:                //#include "Bluetooth.h"
14:                #include "Motors.h"
15:                #include "Globals.h"
16:                #include <math.h>
17:                
18:                // T2_PERIOD is PWM period in microseconds
19:                //#define T2_PERIOD 50L
20:                //#define T2_POST 1L
21:                //#define T2_PR2 (T2_PERIOD)*(F_CY/T2_POST)/1000000L
22:                //#define MICSTEPS 64
23:                //#define PI 3.1415926535897932384626433832795F
24:                //extern union MPU5060 Mpu5060;
25:                //extern union PID Pid;
26:                
27:                
28:                //extern int BroadcastAppend(unsigned char* frame);
29:                
30:                _FOSC(CSW_FSCM_OFF & XT_PLL16);                      // no clock switching , primary clock XT with PLL x 16
31:                _FBORPOR( MCLR_EN); //  MCLR as reset pin
32:                _FWDT(WDT_OFF);                               // watchdog disabled
33:                
34:                
35:                
36:                /* Allocate memory for buffers and drivers	*/
37:                
38:                
39:                
40:                long k;
41:                long h = 100000;
42:                int dir = 1;
43:                int rev = 32000;
44:                int incr = 200;
45:                
46:                struct 
47:                {
48:                    int Tick_100: 1;
49:                    int Tick_200: 1;
50:                    int Tick_400: 1;
51:                    int Tick_800: 1;
52:                    int Tick_1600: 1;
53:                    int Tick_3200: 1;
54:                    int Tick_6400: 1;
55:                    int Tick_12800: 1;
56:                    int Tick_25600: 1;
57:                    int Tick_51200: 1;
58:                    int Tick_102400: 1;
59:                    int Tick_204800: 1;
60:                    int Tick_409600: 1;
61:                    int Tick_819200: 1;
62:                    int Tick_1638400: 1;
63:                    int Tick_3276800: 1;
64:                } Tick, Tick_;
65:                
66:                
67:                
68:                
69:                int main(void)
70:                {
001040  FA0000     LNK #0x0
71:                	/* Configure Oscillator to operate the device at 40MHz.
72:                	 * Fosc= Fin*M/(N1*N2), Fcy=Fosc/4
73:                	 * Fosc= 7.37M*40/(2*2)=80Mhz for 7.37M input clock */
74:                //OSCCONbits.POST
75:                //POST<1:0>: Oscillator Postscaler Selection bits
76:                //11 = Oscillator postscaler divides clock by 64
77:                //10 = Oscillator postscaler divides clock by 16
78:                //01 = Oscillator postscaler divides clock by 4
79:                //00 = Oscillator postscaler does not alter clock
80:                //	SegwayInit();
81:                //	BroadcastAppend(Mpu5060.MPU5060Frame);
82:                //	BroadcastAppend(Pid.PidFrame);
83:                //	BroadcastAppend(Kalman.KalmanFrame);
84:                //	BroadcastAppend(Motors.MotorsFrame);
85:                //
86:                //	BluetoothInit();
87:                        ADCInit();
001042  07FFEB     RCALL ADCInit
88:                	MotorsInit();
001044  07FE80     RCALL MotorsInit
001046  370001     BRA 0x104A
89:                        
90:                	//unsigned int MicStepArray[MICSTEPS];
91:                //	float a = sin(3.1415926535897932384626433832795/2);
92:                //	a=a+a;
93:                
94:                //	int i;
95:                //	union
96:                //	{
97:                //		struct
98:                //		{
99:                //			unsigned int EnA;
100:               //			unsigned int EnB;
101:               //		} MicStepStruct;
102:               //		unsigned long int MicStep;
103:               //	} MicStepUnion;
104:               //	#define INP MicStepUnion.MicStepStruct
105:               //	#define MST MicStepUnion
106:               //	for(i = 0; i < MICSTEPS; i++)
107:               //	{
108:               //		float a, b;
109:               //		a = sin((float)i/(float)(MICSTEPS) * (PI/2));
110:               //		b = ((float)T2_PR2 * sin((float)i/(float)(MICSTEPS) * (PI/2)));
111:               //		INP.EnA = (unsigned int)((float)T2_PR2 * sin((float)i/(float)(MICSTEPS) * (PI/2)));
112:               //		INP.EnB = (unsigned int)((float)T2_PR2 * cos((float)i/(float)(MICSTEPS) * (PI/2)));
113:               //		MicStepArray[i] = MST.MicStep;
114:               //	}
115:               
116:               	while(1)
117:               	{
118:                       if(Tick.Tick_100 && !Tick_.Tick_100)
00104A  804A44     MOV Tick, W4
00104C  620261     AND W4, #0x1, W4
00104E  520FE0     SUB W4, #0x0, [W15]
001050  320018     BRA Z, 0x1082
001052  804A54     MOV Tick_, W4
001054  620261     AND W4, #0x1, W4
001056  520FE0     SUB W4, #0x0, [W15]
001058  3A0014     BRA NZ, 0x1082
119:                       {
120:                           Tick_.Tick_100++;
00105A  804A54     MOV Tick_, W4
00105C  200075     MOV #0x7, W5
00105E  DD2205     SL W4, W5, W4
001060  FB0204     SE W4, W4
001062  DEA247     ASR W4, #7, W4
001064  784204     MOV.B W4, W4
001066  E94204     DEC.B W4, W4
001068  200075     MOV #0x7, W5
00106A  DD2205     SL W4, W5, W4
00106C  FB0204     SE W4, W4
00106E  DEA247     ASR W4, #7, W4
001070  784204     MOV.B W4, W4
001072  FB8204     ZE W4, W4
001074  620261     AND W4, #0x1, W4
001076  804A56     MOV Tick_, W6
001078  2FFFE5     MOV #0xFFFE, W5
00107A  630285     AND W6, W5, W5
00107C  720205     IOR W4, W5, W4
00107E  884A54     MOV W4, Tick_
001080  37001B     BRA 0x10B8
121:                       }
122:                       else if(!Tick.Tick_100 && Tick_.Tick_100)
001082  804A44     MOV Tick, W4
001084  620261     AND W4, #0x1, W4
001086  520FE0     SUB W4, #0x0, [W15]
001088  3A0017     BRA NZ, 0x10B8
00108A  804A54     MOV Tick_, W4
00108C  620261     AND W4, #0x1, W4
00108E  520FE0     SUB W4, #0x0, [W15]
001090  320013     BRA Z, 0x10B8
123:                       {
124:                           Tick_.Tick_100--;
001092  804A54     MOV Tick_, W4
001094  200075     MOV #0x7, W5
001096  DD2205     SL W4, W5, W4
001098  FB0204     SE W4, W4
00109A  DEA247     ASR W4, #7, W4
00109C  784204     MOV.B W4, W4
00109E  E84204     INC.B W4, W4
0010A0  200075     MOV #0x7, W5
0010A2  DD2205     SL W4, W5, W4
0010A4  FB0204     SE W4, W4
0010A6  DEA247     ASR W4, #7, W4
0010A8  784204     MOV.B W4, W4
0010AA  FB8204     ZE W4, W4
0010AC  620261     AND W4, #0x1, W4
0010AE  804A56     MOV Tick_, W6
0010B0  2FFFE5     MOV #0xFFFE, W5
0010B2  630285     AND W6, W5, W5
0010B4  720205     IOR W4, W5, W4
0010B6  884A54     MOV W4, Tick_
125:                       }
126:                       
127:                       if(Tick.Tick_200 && !Tick_.Tick_200)
0010B8  804A44     MOV Tick, W4
0010BA  620262     AND W4, #0x2, W4
0010BC  520FE0     SUB W4, #0x0, [W15]
0010BE  320019     BRA Z, 0x10F2
0010C0  804A54     MOV Tick_, W4
0010C2  620262     AND W4, #0x2, W4
0010C4  520FE0     SUB W4, #0x0, [W15]
0010C6  3A0015     BRA NZ, 0x10F2
128:                       {
129:                           Tick_.Tick_200++;
0010C8  804A54     MOV Tick_, W4
0010CA  200065     MOV #0x6, W5
0010CC  DD2205     SL W4, W5, W4
0010CE  FB0204     SE W4, W4
0010D0  DEA247     ASR W4, #7, W4
0010D2  784204     MOV.B W4, W4
0010D4  E94204     DEC.B W4, W4
0010D6  200075     MOV #0x7, W5
0010D8  DD2205     SL W4, W5, W4
0010DA  FB0204     SE W4, W4
0010DC  DEA247     ASR W4, #7, W4
0010DE  784204     MOV.B W4, W4
0010E0  FB8204     ZE W4, W4
0010E2  620261     AND W4, #0x1, W4
0010E4  420204     ADD W4, W4, W4
0010E6  804A56     MOV Tick_, W6
0010E8  2FFFD5     MOV #0xFFFD, W5
0010EA  630285     AND W6, W5, W5
0010EC  720205     IOR W4, W5, W4
0010EE  884A54     MOV W4, Tick_
0010F0  37001C     BRA 0x112A
130:                       }
131:                       else if(!Tick.Tick_200 && Tick_.Tick_200)
0010F2  804A44     MOV Tick, W4
0010F4  620262     AND W4, #0x2, W4
0010F6  520FE0     SUB W4, #0x0, [W15]
0010F8  3A0018     BRA NZ, 0x112A
0010FA  804A54     MOV Tick_, W4
0010FC  620262     AND W4, #0x2, W4
0010FE  520FE0     SUB W4, #0x0, [W15]
001100  320014     BRA Z, 0x112A
132:                       {
133:                           Tick_.Tick_200--;
001102  804A54     MOV Tick_, W4
001104  200065     MOV #0x6, W5
001106  DD2205     SL W4, W5, W4
001108  FB0204     SE W4, W4
00110A  DEA247     ASR W4, #7, W4
00110C  784204     MOV.B W4, W4
00110E  E84204     INC.B W4, W4
001110  200075     MOV #0x7, W5
001112  DD2205     SL W4, W5, W4
001114  FB0204     SE W4, W4
001116  DEA247     ASR W4, #7, W4
001118  784204     MOV.B W4, W4
00111A  FB8204     ZE W4, W4
00111C  620261     AND W4, #0x1, W4
00111E  420204     ADD W4, W4, W4
001120  804A56     MOV Tick_, W6
001122  2FFFD5     MOV #0xFFFD, W5
001124  630285     AND W6, W5, W5
001126  720205     IOR W4, W5, W4
001128  884A54     MOV W4, Tick_
134:                       }
135:                       
136:                       if(IFS0bits.ADIF == 1)
00112A  800425     MOV IFS0, W5
00112C  208004     MOV #0x800, W4
00112E  628204     AND W5, W4, W4
001130  520FE0     SUB W4, #0x0, [W15]
001132  32FF8A     BRA Z, 0x1048
137:                           IFS0bits.ADIF = 0;
001134  A96085     BCLR 0x85, #3
138:               	}
001048  000000     NOP
001136  37FF89     BRA 0x104A
139:               
140:               }
141:               
142:               
143:               
144:               
---  C:/MCprojects/Segway/Segway/Pid_s.s  ---------------------------------------------------------------
                                                  1:     ;struct Pid
                                                  2:     ;{
                                                  3:     ;   // external
                                                  4:     ;	0 int kp;
                                                  5:     ;	2 int ki;
                                                  6:     ;	4 int kd;
                                                  7:     ;	6 int offset;
                                                  8:     ;	8 int min;
                                                  9:     ;	10 int max;
                                                  10:    ;   12 int inverse;
                                                  11:    ;   // internal
                                                  12:    ;	14 long long int prevI;
                                                  13:    ;   22 int prevIn;
                                                  14:    ;}
                                                  15:    
                                                  16:    ;int PidExec(int in, struct Pid* pid)
                                                  17:    ;{
                                                  18:    ;	int out;
                                                  19:    ;
                                                  20:    ;	i += in * (pid->ki);
                                                  21:    ;	p = in * (pid->kp);
                                                  22:    ;	d = (in - prevIn) * (pid->kd);
                                                  23:    ;	prevIn = in;
                                                  24:    ;	out = p + i + d;
                                                  25:    ;	out >>= 16;
                                                  26:    ;	return out + pid->offset;
                                                  27:    ;}
                                                  28:     .text
                                                  29:     .global _PidExec
                                                  30:    _PidExec:
                                                  31:        ;;;;;;;;;;; siple or inverse control ;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:        ;mov [w2+12], w2         ; fetch previous i value to w2
                                                  33:        ;lac w2, #7, a           ; load previous i value to accumulator
                                                  34:        ;mov w2, w2
001208  9001E2     MOV [W2+12], W3                35:        mov [w2+12], w3          ; fetch inverse value to w3
00120A  E00003     CP0 W3                         36:        cp0 w3                   ; compare inverse value with 0
00120C  3C0002     BRA GT, 0x1212                 37:        bra gt, INVERSE          ; if inverse value >0 skip simple error computing
00120E  508000     SUB W1, W0, W0                 38:        sub w1, w0, w0           ; compute direct error (setp - in)
001210  370001     BRA 0x1214                     39:        bra DIRECT
                                                  40:    INVERSE:
001212  500001     SUB W0, W1, W0                 41:        sub w0, w1, w0           ; compute inverse error ( in - setp)
                                                  42:    DIRECT:
                                                  43:        ;;;;;;;;;;; Integral ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
001214  4100EE     ADD W2, #0xE, W1               44:        add w2, #14, w1          ; to w2 load structure pointer inreased with 12 (prevI)
001216  200223     MOV #0x22, W3                  45:        mov #0x22, w3            ; load ACCA's address to w3
001218  7819B1     MOV [W1++], [W3++]             46:        mov [w1++], [w3++]       ; load ACCA with previous i value
00121A  7819B1     MOV [W1++], [W3++]             47:        mov [w1++], [w3++]       ;
00121C  784991     MOV.B [W1], [W3]               48:        mov.b [w1], [w3]         ;
00121E  780200     MOV W0, W4                     49:    	mov w0, w4              ; load current in to w4
001220  900292     MOV [W2+2], W5                 50:    	mov [w2+2], w5          ; fetch ki to w5
001222  C00112     MAC W4*W5, A                   51:    	mac w4*w5, a            ; multiply current in with ki and accumulate
                                                  52:        ;sac a, #-7, w3          ; preserve current i value
001224  C38112     CLR B                          53:        clr b                    ; preserve current i value in ACCB
001226  CB8000     ADD B                          54:        add b                    ;
                                                  55:        ;;;;;;;;;;; Proportional ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
001228  780292     MOV [W2], W5                   56:        mov [w2], w5            ; fetch kp to w5
00122A  C00112     MAC W4*W5, A                   57:        mac w4*w5, a            ; multiply current in with kp and accumulate
                                                  58:        ;;;;;;;;;;; Derivative ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00122C  9008B2     MOV [W2+22], W1                59:        mov [w2+22], w1         ; fetch prevIn value to w2
00122E  9002A2     MOV [W2+4], W5                 60:        mov [w2+4], w5          ; fetch kd to w5
001230  520201     SUB W4, W1, W4                 61:        sub w4, w1, w4          ; subtract prevIn from current in and result load to w4
001232  C00112     MAC W4*W5, A                   62:        mac w4*w5, a            ; multiply difference (in-prevIn) with kd and accumulate
                                                  63:        ;;;;;;;;;;; Output limit ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
001234  CC0480     SAC A, #-7, W0                 64:        sac a, #-7, w0          ; load PID result to w0
001236  9001B2     MOV [W2+6], W3                 65:        mov [w2+6], w3          ; fetch offset value
001238  400003     ADD W0, W3, W0                 66:        add w0, w3, w0          ; add offset to output
00123A  900252     MOV [W2+10], W4                67:        mov [w2+10], w4         ; fetch max value
00123C  520080     SUB W4, W0, W1                 68:        sub w4, w0, w1          ; subtract max - out to make comparison
00123E  3C0002     BRA GT, 0x1244                 69:        bra gt, OUT_LE_MAX      ; if out <= max jump to OUT_LT_MAX
001240  780004     MOV W4, W0                     70:        mov w4, w0              ; alter w0 with max
001242  37000A     BRA 0x1258                     71:        bra OUT_EQ_MAX
                                                  72:    OUT_LE_MAX:
001244  900242     MOV [W2+8], W4                 73:        mov [w2+8], w4          ; fetch min value
001246  520080     SUB W4, W0, W1                 74:        sub w4, w0, w1          ; subtract max - out to make comparison
001248  350002     BRA LT, 0x124E                 75:        bra lt, OUT_IN_RANGE    ; if out >= min jump to OUT_IN_RANGE
00124A  780004     MOV W4, W0                     76:        mov w4, w0              ; alter w0 with min
00124C  370005     BRA 0x1258                     77:        bra OUT_EQ_MIN
                                                  78:    OUT_IN_RANGE:
                                                  79:        ;mov w3, [w2+12]         ; store current i value
                                                  80:        ;mov w2, w2
00124E  4100EE     ADD W2, #0xE, W1               81:        add w2, #14, w1         ; to w2 load structure pointer inreased with 12 (prevI)
001250  200283     MOV #0x28, W3                  82:        mov #0x28, w3           ; load ACCB's address to w3
001252  7818B3     MOV [W3++], [W1++]             83:        mov [w3++], [w1++]      ; store current i value (ACCB)
001254  7818B3     MOV [W3++], [W1++]             84:        mov [w3++], [w1++]      ;
001256  7858B3     MOV.B [W3++], [W1++]           85:        mov.b [w3++], [w1++]    ;
                                                  86:    OUT_EQ_MAX:
                                                  87:    OUT_EQ_MIN:
                                                  88:    ;mov w1, w0		    ; to bypas Pid algorithm uncoment this and comment all the rest
001258  060000     RETURN                         89:      return
                                                  90:     .end
---  C:/MCprojects/Segway/Segway/Motor.c  ---------------------------------------------------------------
1:                 /**********************************************************************c
2:                 * Author: Marcin Dec
3:                 * Date: 11.08.2015
4:                 * FileName:        Motor.c
5:                 * Dependencies:    Header Motor.h
6:                 * Processor:       dsPIC30F6013A
7:                 * Compiler:        MPLAB® XC16 C Compiler
8:                 *
9:                 ************************************************************************/
10:                #include <p30f6013A.h>
11:                #include <math.h>
12:                #include "Globals.h"
13:                #include "Motors.h"
14:                #include "Pid.h"
15:                #include "ADC.h"
16:                
17:                //// Timer 2 period in microseconds ///////////////////////////////
18:                #define T2_PERIOD 50L
19:                //// Timer 2 postscaler factor ////////////////////////////////////
20:                #define T2_POST 1L
21:                //// Timer 2 reload value = 1474/////////////////////////////////////////
22:                #define T2_PR2 (T2_PERIOD)*(F_CY/T2_POST)/1000000L
23:                //// Step Motor microsteps ///////////////////////////////////////
24:                //#define MICSTEPS 64
25:                
26:                #define PI 3.1415926535897932384626433832795F
27:                //// Timer 2 postscaler register value ///////////////////////////
28:                #if (T2_POST == 256)
29:                	#define T2_TCKPS 3
30:                #elif (T2_POST == 64)
31:                	#define T2_TCKPS 2
32:                #elif (T2_POST == 8)
33:                	#define T2_TCKPS 1
34:                #elif (T2_POST == 1)
35:                	#define T2_TCKPS 0
36:                #else
37:                	#error "T2_POST must be selected from set {1, 8, 64, 256} "
38:                #endif
39:                
40:                
41:                
42:                
43:                //unsigned int DecaySin = 0;
44:                //unsigned int DecayCos = 10;
45:                
46:                //int Rev = 32000;
47:                //int Presc = 0;				// Revolution control prescaler
48:                //int MicStep = 0;			// Sine-Cosine look-up array index (MicStepArray[])
49:                //int MICSTEPS = 16;
50:                //int StepIndx = 0;
51:                //int StepIncLatch = 1;
52:                //int StepInc = 0;
53:                //int PrescVal = 0;
54:                //int PrescValLatch = 1250;
55:                //int SpeedAbs = 0;
56:                //int Speed = 0;
57:                //int Direction = 1;
58:                //int Present = 0;
59:                //int SpeedChange = 1;
60:                //int Tick = 0;
61:                //int PhaseAfwd = 1;
62:                //int PhaseArev = 0;
63:                //int PhaseBfwd = 1;
64:                int debug = 0;
65:                int DebugSet = 5;
66:                int ADCon1_m;
67:                int temp;
68:                
69:                const int MICSTEPS = 16;
70:                const int SPEED_SLEWRATE = 1;
71:                extern __psv__ unsigned int SPEED_CURVE[251][3] __attribute__((space(psv)));
72:                extern const    int __attribute__((space(auto_psv),aligned)) Sin90[17];
73:                extern const    int __attribute__((space(auto_psv),aligned)) Cos90[17];
74:                extern void Ticks(void);
75:                extern struct
76:                {
77:                } Tick;
78:                //unsigned int Sin90[17]; //MICSTEPS + 1
79:                //unsigned int Cos90[17]; //MICSTEPS + 1
80:                
81:                struct Motor
82:                {
83:                    int StepPresc;  // = 0;			// Micro step prescaler counter
84:                    int MicStep;    // = 0;			// Micro step counter
85:                    int StepIncLatch;   // = 1;                 // Micro step increment latch register
86:                    int StepInc;    // = 0;                     // Micro step increment
87:                    int StepPrescVal;   // = 0;                 // Micro step prescaler compare value
88:                    int StepPrescValLatch;  // = 1250;          // Micro step prescaler compare value latch register
89:                    int SpeedAbs;   // = 0;                     // Current motor speed absolute value
90:                    int Speed;  // = 0;                         // Current motor speed
91:                    int InputSpeed;  // = 0;                    // Input speed from external
92:                    int Direction;  // = 1;                     // Direction auxiliary variable
93:                    unsigned int DecaySin; // = 0;              // Decay % value for rising slope
94:                    unsigned int DecayCos; // = 10;             // Decay % value for falling slope
95:                    unsigned int Oc84rs; // = 0;                // Decay control auxiliary register
96:                    unsigned int Oc73rs; // = 0;                // Decay control auxiliary register
97:                    unsigned int Oc62rs; // = 0;                // Decay control auxiliary register
98:                    unsigned int Oc51rs; // = 0;                // Decay control auxiliary register
99:                    unsigned int Oc84r; // = 0;                 // Decay control auxiliary register
100:                   unsigned int Oc73r; // = 0;                 // Decay control auxiliary register
101:                   unsigned int Oc62r; // = 0;                 // Decay control auxiliary register
102:                   unsigned int Oc51r; // = 0;                 // Decay control auxiliary register
103:               }
104:               MotorLeft = {0, 0, 1, 0, 0, 1250, 0, 0, 50, 1, 10,0,0,0,0,0,0,0,0},
105:               MotorRight = {0, 0, 1, 0, 0, 1250, 0, 0, 0, 1, 10,0,0,0,0,0,0,0,0};
106:               
107:               //unsigned long int MicStepArray[17]; //  [MICSTEPS+1]
108:               //union
109:               //{
110:               //	struct
111:               //	{
112:               //		unsigned int Sin90;
113:               //		unsigned int Cos90;
114:               //	} MicStepStruct;
115:               //	unsigned long int MicStep;
116:               //} MicStepUnion;
117:               //#define INP MicStepUnion.MicStepStruct
118:               //#define MST MicStepUnion
119:               
120:               void SpeedSlewRate(struct Motor* motor )
121:               {
0005DE  FA0002     LNK #0x2
0005E0  780F00     MOV W0, [W14]
122:                   if(motor->InputSpeed > motor->Speed)
0005E2  78021E     MOV [W14], W4
0005E4  900A84     MOV [W4+16], W5
0005E6  78021E     MOV [W14], W4
0005E8  900274     MOV [W4+14], W4
0005EA  528F84     SUB W5, W4, [W15]
0005EC  340011     BRA LE, 0x610
123:                   {
124:                       motor->Speed += SPEED_SLEWRATE;
0005EE  78021E     MOV [W14], W4
0005F0  9002F4     MOV [W4+14], W5
0005F2  842EE4     MOV 0x85DC, W4
0005F4  428284     ADD W5, W4, W5
0005F6  78021E     MOV [W14], W4
0005F8  980275     MOV W5, [W4+14]
125:                       if(motor->Speed > motor->InputSpeed)
0005FA  78021E     MOV [W14], W4
0005FC  9002F4     MOV [W4+14], W5
0005FE  78021E     MOV [W14], W4
000600  900A04     MOV [W4+16], W4
000602  528F84     SUB W5, W4, [W15]
000604  34001B     BRA LE, 0x63C
126:                           motor->Speed = motor->InputSpeed;
000606  78021E     MOV [W14], W4
000608  900A84     MOV [W4+16], W5
00060A  78021E     MOV [W14], W4
00060C  980275     MOV W5, [W4+14]
00060E  370016     BRA 0x63C
127:                   }
128:                   else if(motor->InputSpeed < motor->Speed)
000610  78021E     MOV [W14], W4
000612  900A84     MOV [W4+16], W5
000614  78021E     MOV [W14], W4
000616  900274     MOV [W4+14], W4
000618  528F84     SUB W5, W4, [W15]
00061A  3D0010     BRA GE, 0x63C
129:                   {
130:                       motor->Speed -= SPEED_SLEWRATE;
00061C  78021E     MOV [W14], W4
00061E  9002F4     MOV [W4+14], W5
000620  842EE4     MOV 0x85DC, W4
000622  528284     SUB W5, W4, W5
000624  78021E     MOV [W14], W4
000626  980275     MOV W5, [W4+14]
131:                       if(motor->Speed < motor->InputSpeed)
000628  78021E     MOV [W14], W4
00062A  9002F4     MOV [W4+14], W5
00062C  78021E     MOV [W14], W4
00062E  900A04     MOV [W4+16], W4
000630  528F84     SUB W5, W4, [W15]
000632  3D0004     BRA GE, 0x63C
132:                           motor->Speed = motor->InputSpeed;
000634  78021E     MOV [W14], W4
000636  900A84     MOV [W4+16], W5
000638  78021E     MOV [W14], W4
00063A  980275     MOV W5, [W4+14]
133:                   }
134:               }
00063C  FA8000     ULNK
00063E  060000     RETURN
135:               inline void MotorRightDecayLoad(void)
136:               {
000640  FA0000     LNK #0x0
137:                   if(MotorRight.MicStep/MICSTEPS == 0)		// sin >0, cos >0
000642  8048A5     MOV 0x914, W5
000644  842ED4     MOV 0x85DA, W4
000646  090011     REPEAT #0x11
000648  D80284     DIV.SW W5, W4
00064A  780200     MOV W0, W4
00064C  520FE0     SUB W4, #0x0, [W15]
00064E  3A0009     BRA NZ, 0x662
138:                   {
139:                       OC7R = MotorRight.Oc73r;
000650  8049A4     MOV 0x934, W4
000652  880D34     MOV W4, OC7R
140:                       OC7RS = MotorRight.Oc73rs;
000654  804964     MOV 0x92C, W4
000656  880D24     MOV W4, OC7RS
141:                       OC5R = MotorRight.Oc51r;
000658  8049C4     MOV 0x938, W4
00065A  880CD4     MOV W4, OC5R
142:                       OC5RS = MotorRight.Oc51rs;
00065C  804984     MOV 0x930, W4
00065E  880CC4     MOV W4, OC5RS
000660  37002F     BRA 0x6C0
143:                   }
144:                   else if(MotorRight.MicStep/MICSTEPS == 1)		// sin >0, cos <0
000662  8048A5     MOV 0x914, W5
000664  842ED4     MOV 0x85DA, W4
000666  090011     REPEAT #0x11
000668  D80284     DIV.SW W5, W4
00066A  780200     MOV W0, W4
00066C  520FE1     SUB W4, #0x1, [W15]
00066E  3A0009     BRA NZ, 0x682
145:                   {
146:                       OC7R = MotorRight.Oc73r;
000670  8049A4     MOV 0x934, W4
000672  880D34     MOV W4, OC7R
147:                       OC7RS = MotorRight.Oc73rs;
000674  804964     MOV 0x92C, W4
000676  880D24     MOV W4, OC7RS
148:                       OC6R = MotorRight.Oc62r;
000678  8049B4     MOV 0x936, W4
00067A  880D04     MOV W4, OC6R
149:                       OC6RS = MotorRight.Oc62rs;
00067C  804974     MOV 0x92E, W4
00067E  880CF4     MOV W4, OC6RS
000680  37001F     BRA 0x6C0
150:                   }
151:                   else if(MotorRight.MicStep/MICSTEPS == 2)		// sin <0, cos <0
000682  8048A5     MOV 0x914, W5
000684  842ED4     MOV 0x85DA, W4
000686  090011     REPEAT #0x11
000688  D80284     DIV.SW W5, W4
00068A  780200     MOV W0, W4
00068C  520FE2     SUB W4, #0x2, [W15]
00068E  3A0009     BRA NZ, 0x6A2
152:                   {
153:                       OC8R = MotorRight.Oc84r;
000690  804994     MOV 0x932, W4
000692  880D64     MOV W4, OC8R
154:                       OC8RS = MotorRight.Oc84rs;
000694  804954     MOV 0x92A, W4
000696  880D54     MOV W4, OC8RS
155:                       OC6R = MotorRight.Oc62r;
000698  8049B4     MOV 0x936, W4
00069A  880D04     MOV W4, OC6R
156:                       OC6RS = MotorRight.Oc62rs;
00069C  804974     MOV 0x92E, W4
00069E  880CF4     MOV W4, OC6RS
0006A0  37000F     BRA 0x6C0
157:                   }
158:                   else if(MotorRight.MicStep/MICSTEPS == 3)		// sin <0, cos >0
0006A2  8048A5     MOV 0x914, W5
0006A4  842ED4     MOV 0x85DA, W4
0006A6  090011     REPEAT #0x11
0006A8  D80284     DIV.SW W5, W4
0006AA  780200     MOV W0, W4
0006AC  520FE3     SUB W4, #0x3, [W15]
0006AE  3A0008     BRA NZ, 0x6C0
159:                   {
160:                       OC8R = MotorRight.Oc84r;
0006B0  804994     MOV 0x932, W4
0006B2  880D64     MOV W4, OC8R
161:                       OC8RS = MotorRight.Oc84rs;
0006B4  804954     MOV 0x92A, W4
0006B6  880D54     MOV W4, OC8RS
162:                       OC5R = MotorRight.Oc51r;
0006B8  8049C4     MOV 0x938, W4
0006BA  880CD4     MOV W4, OC5R
163:                       OC5RS = MotorRight.Oc51rs;
0006BC  804984     MOV 0x930, W4
0006BE  880CC4     MOV W4, OC5RS
164:                   }
165:               }
0006C0  FA8000     ULNK
0006C2  060000     RETURN
166:               
167:               inline void MotorLeftDecayLoad(void)
168:               {
0006C4  FA0000     LNK #0x0
169:                   if(MotorLeft.MicStep/MICSTEPS == 0)			// sin >0, cos >0
0006C6  804765     MOV 0x8EC, W5
0006C8  842ED4     MOV 0x85DA, W4
0006CA  090011     REPEAT #0x11
0006CC  D80284     DIV.SW W5, W4
0006CE  780200     MOV W0, W4
0006D0  520FE0     SUB W4, #0x0, [W15]
0006D2  3A0009     BRA NZ, 0x6E6
170:                   {
171:                       OC3R = MotorLeft.Oc73r;
0006D4  804864     MOV 0x90C, W4
0006D6  880C74     MOV W4, OC3R
172:                       OC3RS = MotorLeft.Oc73rs;
0006D8  804824     MOV 0x904, W4
0006DA  880C64     MOV W4, OC3RS
173:                       OC1R = MotorLeft.Oc51r;
0006DC  804884     MOV 0x910, W4
0006DE  880C14     MOV W4, OC1R
174:                       OC1RS = MotorLeft.Oc51rs;
0006E0  804844     MOV 0x908, W4
0006E2  880C04     MOV W4, OC1RS
0006E4  37002F     BRA 0x744
175:                   }
176:                   else if(MotorLeft.MicStep/MICSTEPS == 1)		// sin >0, cos <0
0006E6  804765     MOV 0x8EC, W5
0006E8  842ED4     MOV 0x85DA, W4
0006EA  090011     REPEAT #0x11
0006EC  D80284     DIV.SW W5, W4
0006EE  780200     MOV W0, W4
0006F0  520FE1     SUB W4, #0x1, [W15]
0006F2  3A0009     BRA NZ, 0x706
177:                   {
178:                       OC3R = MotorLeft.Oc73r;
0006F4  804864     MOV 0x90C, W4
0006F6  880C74     MOV W4, OC3R
179:                       OC3RS = MotorLeft.Oc73rs;
0006F8  804824     MOV 0x904, W4
0006FA  880C64     MOV W4, OC3RS
180:                       OC2R = MotorLeft.Oc62r;
0006FC  804874     MOV 0x90E, W4
0006FE  880C44     MOV W4, OC2R
181:                       OC2RS = MotorLeft.Oc62rs;
000700  804834     MOV 0x906, W4
000702  880C34     MOV W4, OC2RS
000704  37001F     BRA 0x744
182:                   }
183:                   else if(MotorLeft.MicStep/MICSTEPS == 2)		// sin <0, cos <0
000706  804765     MOV 0x8EC, W5
000708  842ED4     MOV 0x85DA, W4
00070A  090011     REPEAT #0x11
00070C  D80284     DIV.SW W5, W4
00070E  780200     MOV W0, W4
000710  520FE2     SUB W4, #0x2, [W15]
000712  3A0009     BRA NZ, 0x726
184:                   {
185:                       OC4R = MotorLeft.Oc84r;
000714  804854     MOV 0x90A, W4
000716  880CA4     MOV W4, OC4R
186:                       OC4RS = MotorLeft.Oc84rs;
000718  804814     MOV 0x902, W4
00071A  880C94     MOV W4, OC4RS
187:                       OC2R = MotorLeft.Oc62r;
00071C  804874     MOV 0x90E, W4
00071E  880C44     MOV W4, OC2R
188:                       OC2RS = MotorLeft.Oc62rs;
000720  804834     MOV 0x906, W4
000722  880C34     MOV W4, OC2RS
000724  37000F     BRA 0x744
189:                   }
190:                   else if(MotorLeft.MicStep/MICSTEPS == 3)		// sin <0, cos >0
000726  804765     MOV 0x8EC, W5
000728  842ED4     MOV 0x85DA, W4
00072A  090011     REPEAT #0x11
00072C  D80284     DIV.SW W5, W4
00072E  780200     MOV W0, W4
000730  520FE3     SUB W4, #0x3, [W15]
000732  3A0008     BRA NZ, 0x744
191:                   {
192:                       OC4R = MotorLeft.Oc84r;
000734  804854     MOV 0x90A, W4
000736  880CA4     MOV W4, OC4R
193:                       OC4RS = MotorLeft.Oc84rs;
000738  804814     MOV 0x902, W4
00073A  880C94     MOV W4, OC4RS
194:                       OC1R = MotorLeft.Oc51r;
00073C  804884     MOV 0x910, W4
00073E  880C14     MOV W4, OC1R
195:                       OC1RS = MotorLeft.Oc51rs;
000740  804844     MOV 0x908, W4
000742  880C04     MOV W4, OC1RS
196:                   }
197:               }
000744  FA8000     ULNK
000746  060000     RETURN
198:               inline void MotorDecayLoad(void)
199:               {
000748  FA0000     LNK #0x0
200:                   MotorRightDecayLoad();
00074A  07FF7A     RCALL MotorRightDecayLoad
201:                   MotorLeftDecayLoad();
00074C  07FFBB     RCALL MotorLeftDecayLoad
202:               }
00074E  FA8000     ULNK
000750  060000     RETURN
203:               //inline PidIterate(void)
204:               //{
205:               //    PidExec(ADCCSARight, setp, &PidCSAR)
206:               //}
207:               inline void MotorRightDriver(void)
208:               {
000752  FA0000     LNK #0x0
209:                   
210:               
211:                   if(MotorRight.MicStep/MICSTEPS == 0)			// sin >0, cos >0
000754  8048A5     MOV 0x914, W5
000756  842ED4     MOV 0x85DA, W4
000758  090011     REPEAT #0x11
00075A  D80284     DIV.SW W5, W4
00075C  780200     MOV W0, W4
00075E  520FE0     SUB W4, #0x0, [W15]
000760  3A008F     BRA NZ, 0x880
212:                   {
213:                       // Phase A //////
214:                       // Present Sin = 0 and loaded next value, DecaySin
215:                       // Polarisation positive
216:                       //MST.MicStep = MicStepArray[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch];
217:                       if(MotorRight.Direction)
000762  804924     MOV 0x924, W4
000764  520FE0     SUB W4, #0x0, [W15]
000766  320013     BRA Z, 0x78E
218:                       {
219:                            if(OC8CONbits.OCM != 0b110)
000768  800D74     MOV OC8CON, W4
00076A  620267     AND W4, #0x7, W4
00076C  520FE6     SUB W4, #0x6, [W15]
00076E  320005     BRA Z, 0x77A
220:                            OC8CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000770  800D74     MOV OC8CON, W4
000772  A10004     BCLR W4, #0
000774  A01004     BSET W4, #1
000776  A02004     BSET W4, #2
000778  880D74     MOV W4, OC8CON
221:                            if(OC7CONbits.OCM != 0b101)
00077A  800D44     MOV OC7CON, W4
00077C  620267     AND W4, #0x7, W4
00077E  520FE5     SUB W4, #0x5, [W15]
000780  320018     BRA Z, 0x7B2
222:                            OC7CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
000782  800D44     MOV OC7CON, W4
000784  A00004     BSET W4, #0
000786  A11004     BCLR W4, #1
000788  A02004     BSET W4, #2
00078A  880D44     MOV W4, OC7CON
00078C  370012     BRA 0x7B2
223:                       }
224:                       else
225:                       {
226:                           if(OC6CONbits.OCM != 0b110)
00078E  800D14     MOV OC6CON, W4
000790  620267     AND W4, #0x7, W4
000792  520FE6     SUB W4, #0x6, [W15]
000794  320005     BRA Z, 0x7A0
227:                           OC6CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000796  800D14     MOV OC6CON, W4
000798  A10004     BCLR W4, #0
00079A  A01004     BSET W4, #1
00079C  A02004     BSET W4, #2
00079E  880D14     MOV W4, OC6CON
228:                           if(OC5CONbits.OCM != 0b101)
0007A0  800CE4     MOV OC5CON, W4
0007A2  620267     AND W4, #0x7, W4
0007A4  520FE5     SUB W4, #0x5, [W15]
0007A6  320005     BRA Z, 0x7B2
229:                           OC5CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
0007A8  800CE4     MOV OC5CON, W4
0007AA  A00004     BSET W4, #0
0007AC  A11004     BCLR W4, #1
0007AE  A02004     BSET W4, #2
0007B0  880CE4     MOV W4, OC5CON
230:                       }
231:                       OC8RS = PidExec(ADCCSARight, Sin90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSAR);
0007B2  8048A5     MOV 0x914, W5
0007B4  842ED4     MOV 0x85DA, W4
0007B6  090011     REPEAT #0x11
0007B8  D80284     DIV.SW W5, W4
0007BA  780201     MOV W1, W4
0007BC  780284     MOV W4, W5
0007BE  8048B4     MOV 0x916, W4
0007C0  428204     ADD W5, W4, W4
0007C2  420284     ADD W4, W4, W5
0007C4  285AC4     MOV #0x85AC, W4
0007C6  428204     ADD W5, W4, W4
0007C8  780294     MOV [W4], W5
0007CA  8044E4     MOV ADCCSARight, W4
0007CC  208002     MOV #0x800, W2
0007CE  780085     MOV W5, W1
0007D0  780004     MOV W4, W0
0007D2  07051A     RCALL _PidExec
0007D4  780200     MOV W0, W4
0007D6  880D54     MOV W4, OC8RS
232:                       MotorRight.Oc73r = OC8RS;
0007D8  800D54     MOV OC8RS, W4
0007DA  8849A4     MOV W4, 0x934
233:                       if((MotorRight.Oc73r + 10) >= PR2)
0007DC  8049A4     MOV 0x934, W4
0007DE  4202EA     ADD W4, #0xA, W5
0007E0  800864     MOV PR2, W4
0007E2  528F84     SUB W5, W4, [W15]
0007E4  390006     BRA NC, 0x7F2
234:                           OC7CONbits.OCM = 0b000;                 // Disable fast deccay
0007E6  800D44     MOV OC7CON, W4
0007E8  A10004     BCLR W4, #0
0007EA  A11004     BCLR W4, #1
0007EC  A12004     BCLR W4, #2
0007EE  880D44     MOV W4, OC7CON
0007F0  370005     BRA 0x7FC
235:                       else OC7CONbits.OCM = 0b101;
0007F2  800D44     MOV OC7CON, W4
0007F4  A00004     BSET W4, #0
0007F6  A11004     BCLR W4, #1
0007F8  A02004     BSET W4, #2
0007FA  880D44     MOV W4, OC7CON
236:                       MotorRight.Oc73rs = 2 + MotorRight.Oc73r + (PR2 - MotorRight.Oc73r) * MotorRight.DecaySin / 100;
0007FC  8049A6     MOV 0x934, W6
0007FE  800865     MOV PR2, W5
000800  8049A4     MOV 0x934, W4
000802  528284     SUB W5, W4, W5
000804  804934     MOV 0x926, W4
000806  B9AA04     MUL.SS W5, W4, W4
000808  780284     MOV W4, W5
00080A  200644     MOV #0x64, W4
00080C  090011     REPEAT #0x11
00080E  D88284     DIV.UW W5, W4
000810  780200     MOV W0, W4
000812  430204     ADD W6, W4, W4
000814  E88204     INC2 W4, W4
000816  884964     MOV W4, 0x92C
237:                       // Phase B //////
238:                       // Present Cos = 1 and loaded next value, DecayCos
239:                       OC6RS = PidExec(ADCCSBRight,Cos90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSBR);
000818  8048A5     MOV 0x914, W5
00081A  842ED4     MOV 0x85DA, W4
00081C  090011     REPEAT #0x11
00081E  D80284     DIV.SW W5, W4
000820  780201     MOV W1, W4
000822  780284     MOV W4, W5
000824  8048B4     MOV 0x916, W4
000826  428204     ADD W5, W4, W4
000828  420284     ADD W4, W4, W5
00082A  2858A4     MOV #0x858A, W4
00082C  428204     ADD W5, W4, W4
00082E  780294     MOV [W4], W5
000830  8044F4     MOV ADCCSBRight, W4
000832  208182     MOV #0x818, W2
000834  780085     MOV W5, W1
000836  780004     MOV W4, W0
000838  0704E7     RCALL _PidExec
00083A  780200     MOV W0, W4
00083C  880CF4     MOV W4, OC6RS
240:                       MotorRight.Oc51r = OC6RS;
00083E  800CF4     MOV OC6RS, W4
000840  8849C4     MOV W4, 0x938
241:                       if((MotorRight.Oc51r + 10) >= PR2)
000842  8049C4     MOV 0x938, W4
000844  4202EA     ADD W4, #0xA, W5
000846  800864     MOV PR2, W4
000848  528F84     SUB W5, W4, [W15]
00084A  390006     BRA NC, 0x858
242:                           OC5CONbits.OCM = 0b000;                 // Disable fast deccay
00084C  800CE4     MOV OC5CON, W4
00084E  A10004     BCLR W4, #0
000850  A11004     BCLR W4, #1
000852  A12004     BCLR W4, #2
000854  880CE4     MOV W4, OC5CON
000856  370005     BRA 0x862
243:                       else OC5CONbits.OCM = 0b101;
000858  800CE4     MOV OC5CON, W4
00085A  A00004     BSET W4, #0
00085C  A11004     BCLR W4, #1
00085E  A02004     BSET W4, #2
000860  880CE4     MOV W4, OC5CON
244:                       MotorRight.Oc51rs = 2 + MotorRight.Oc51r + (PR2 - MotorRight.Oc51r) * MotorRight.DecayCos / 100;
000862  8049C6     MOV 0x938, W6
000864  800865     MOV PR2, W5
000866  8049C4     MOV 0x938, W4
000868  528284     SUB W5, W4, W5
00086A  804944     MOV 0x928, W4
00086C  B9AA04     MUL.SS W5, W4, W4
00086E  780284     MOV W4, W5
000870  200644     MOV #0x64, W4
000872  090011     REPEAT #0x11
000874  D88284     DIV.UW W5, W4
000876  780200     MOV W0, W4
000878  430204     ADD W6, W4, W4
00087A  E88204     INC2 W4, W4
00087C  884984     MOV W4, 0x930
00087E  3701C1     BRA 0xC02
245:                   }
246:                   else if(MotorRight.MicStep/MICSTEPS == 1)		// sin >0, cos <0
000880  8048A5     MOV 0x914, W5
000882  842ED4     MOV 0x85DA, W4
000884  090011     REPEAT #0x11
000886  D80284     DIV.SW W5, W4
000888  780200     MOV W0, W4
00088A  520FE1     SUB W4, #0x1, [W15]
00088C  3A008F     BRA NZ, 0x9AC
247:                   {
248:                       // Phase A //////
249:                       // Present Cos = 1 and loaded next value, DecayCos
250:                       //MST.MicStep = MicStepArray[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch];
251:                       if(MotorRight.Direction)
00088E  804924     MOV 0x924, W4
000890  520FE0     SUB W4, #0x0, [W15]
000892  320013     BRA Z, 0x8BA
252:                       {
253:                           if(OC6CONbits.OCM != 0b101)
000894  800D14     MOV OC6CON, W4
000896  620267     AND W4, #0x7, W4
000898  520FE5     SUB W4, #0x5, [W15]
00089A  320005     BRA Z, 0x8A6
254:                           OC6CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
00089C  800D14     MOV OC6CON, W4
00089E  A00004     BSET W4, #0
0008A0  A11004     BCLR W4, #1
0008A2  A02004     BSET W4, #2
0008A4  880D14     MOV W4, OC6CON
255:                           if(OC5CONbits.OCM != 0b110)
0008A6  800CE4     MOV OC5CON, W4
0008A8  620267     AND W4, #0x7, W4
0008AA  520FE6     SUB W4, #0x6, [W15]
0008AC  320018     BRA Z, 0x8DE
256:                           OC5CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
0008AE  800CE4     MOV OC5CON, W4
0008B0  A10004     BCLR W4, #0
0008B2  A01004     BSET W4, #1
0008B4  A02004     BSET W4, #2
0008B6  880CE4     MOV W4, OC5CON
0008B8  370012     BRA 0x8DE
257:                       }
258:                       else
259:                       {
260:                            if(OC8CONbits.OCM != 0b110)
0008BA  800D74     MOV OC8CON, W4
0008BC  620267     AND W4, #0x7, W4
0008BE  520FE6     SUB W4, #0x6, [W15]
0008C0  320005     BRA Z, 0x8CC
261:                            OC8CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
0008C2  800D74     MOV OC8CON, W4
0008C4  A10004     BCLR W4, #0
0008C6  A01004     BSET W4, #1
0008C8  A02004     BSET W4, #2
0008CA  880D74     MOV W4, OC8CON
262:                            if(OC7CONbits.OCM != 0b101)
0008CC  800D44     MOV OC7CON, W4
0008CE  620267     AND W4, #0x7, W4
0008D0  520FE5     SUB W4, #0x5, [W15]
0008D2  320005     BRA Z, 0x8DE
263:                            OC7CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
0008D4  800D44     MOV OC7CON, W4
0008D6  A00004     BSET W4, #0
0008D8  A11004     BCLR W4, #1
0008DA  A02004     BSET W4, #2
0008DC  880D44     MOV W4, OC7CON
264:                       }
265:                       OC8RS = PidExec(ADCCSARight,Cos90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSAR);
0008DE  8048A5     MOV 0x914, W5
0008E0  842ED4     MOV 0x85DA, W4
0008E2  090011     REPEAT #0x11
0008E4  D80284     DIV.SW W5, W4
0008E6  780201     MOV W1, W4
0008E8  780284     MOV W4, W5
0008EA  8048B4     MOV 0x916, W4
0008EC  428204     ADD W5, W4, W4
0008EE  420284     ADD W4, W4, W5
0008F0  2858A4     MOV #0x858A, W4
0008F2  428204     ADD W5, W4, W4
0008F4  780294     MOV [W4], W5
0008F6  8044E4     MOV ADCCSARight, W4
0008F8  208002     MOV #0x800, W2
0008FA  780085     MOV W5, W1
0008FC  780004     MOV W4, W0
0008FE  070484     RCALL _PidExec
000900  780200     MOV W0, W4
000902  880D54     MOV W4, OC8RS
266:                       MotorRight.Oc73r = OC8RS;
000904  800D54     MOV OC8RS, W4
000906  8849A4     MOV W4, 0x934
267:                       if((MotorRight.Oc73r + 10) >= PR2)
000908  8049A4     MOV 0x934, W4
00090A  4202EA     ADD W4, #0xA, W5
00090C  800864     MOV PR2, W4
00090E  528F84     SUB W5, W4, [W15]
000910  390006     BRA NC, 0x91E
268:                           OC7CONbits.OCM = 0b000;                 // Disable fast deccay
000912  800D44     MOV OC7CON, W4
000914  A10004     BCLR W4, #0
000916  A11004     BCLR W4, #1
000918  A12004     BCLR W4, #2
00091A  880D44     MOV W4, OC7CON
00091C  370005     BRA 0x928
269:                       else OC7CONbits.OCM = 0b101;
00091E  800D44     MOV OC7CON, W4
000920  A00004     BSET W4, #0
000922  A11004     BCLR W4, #1
000924  A02004     BSET W4, #2
000926  880D44     MOV W4, OC7CON
270:                       MotorRight.Oc73rs = 2 + MotorRight.Oc73r + (PR2 - MotorRight.Oc73r) * MotorRight.DecayCos / 100;
000928  8049A6     MOV 0x934, W6
00092A  800865     MOV PR2, W5
00092C  8049A4     MOV 0x934, W4
00092E  528284     SUB W5, W4, W5
000930  804944     MOV 0x928, W4
000932  B9AA04     MUL.SS W5, W4, W4
000934  780284     MOV W4, W5
000936  200644     MOV #0x64, W4
000938  090011     REPEAT #0x11
00093A  D88284     DIV.UW W5, W4
00093C  780200     MOV W0, W4
00093E  430204     ADD W6, W4, W4
000940  E88204     INC2 W4, W4
000942  884964     MOV W4, 0x92C
271:                       // Phase B //////
272:                       // Present Sin = 0 and loaded next value, DecaySin
273:                       // Polarisation negative
274:               
275:                       OC5RS = PidExec(ADCCSBRight, Sin90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSBR);
000944  8048A5     MOV 0x914, W5
000946  842ED4     MOV 0x85DA, W4
000948  090011     REPEAT #0x11
00094A  D80284     DIV.SW W5, W4
00094C  780201     MOV W1, W4
00094E  780284     MOV W4, W5
000950  8048B4     MOV 0x916, W4
000952  428204     ADD W5, W4, W4
000954  420284     ADD W4, W4, W5
000956  285AC4     MOV #0x85AC, W4
000958  428204     ADD W5, W4, W4
00095A  780294     MOV [W4], W5
00095C  8044F4     MOV ADCCSBRight, W4
00095E  208182     MOV #0x818, W2
000960  780085     MOV W5, W1
000962  780004     MOV W4, W0
000964  070451     RCALL _PidExec
000966  780200     MOV W0, W4
000968  880CC4     MOV W4, OC5RS
276:                       MotorRight.Oc62r = OC5RS;
00096A  800CC4     MOV OC5RS, W4
00096C  8849B4     MOV W4, 0x936
277:                       if((MotorRight.Oc62r + 10) >= PR2)
00096E  8049B4     MOV 0x936, W4
000970  4202EA     ADD W4, #0xA, W5
000972  800864     MOV PR2, W4
000974  528F84     SUB W5, W4, [W15]
000976  390006     BRA NC, 0x984
278:                           OC6CONbits.OCM = 0b000;                 // Disable fast deccay
000978  800D14     MOV OC6CON, W4
00097A  A10004     BCLR W4, #0
00097C  A11004     BCLR W4, #1
00097E  A12004     BCLR W4, #2
000980  880D14     MOV W4, OC6CON
000982  370005     BRA 0x98E
279:                       else OC6CONbits.OCM = 0b101;
000984  800D14     MOV OC6CON, W4
000986  A00004     BSET W4, #0
000988  A11004     BCLR W4, #1
00098A  A02004     BSET W4, #2
00098C  880D14     MOV W4, OC6CON
280:                       MotorRight.Oc62rs = 2 + MotorRight.Oc62r + (PR2 - MotorRight.Oc62r) * MotorRight.DecaySin / 100;
00098E  8049B6     MOV 0x936, W6
000990  800865     MOV PR2, W5
000992  8049B4     MOV 0x936, W4
000994  528284     SUB W5, W4, W5
000996  804934     MOV 0x926, W4
000998  B9AA04     MUL.SS W5, W4, W4
00099A  780284     MOV W4, W5
00099C  200644     MOV #0x64, W4
00099E  090011     REPEAT #0x11
0009A0  D88284     DIV.UW W5, W4
0009A2  780200     MOV W0, W4
0009A4  430204     ADD W6, W4, W4
0009A6  E88204     INC2 W4, W4
0009A8  884974     MOV W4, 0x92E
0009AA  37012B     BRA 0xC02
281:                   }
282:                   else if(MotorRight.MicStep/MICSTEPS == 2)		// sin <0, cos <0
0009AC  8048A5     MOV 0x914, W5
0009AE  842ED4     MOV 0x85DA, W4
0009B0  090011     REPEAT #0x11
0009B2  D80284     DIV.SW W5, W4
0009B4  780200     MOV W0, W4
0009B6  520FE2     SUB W4, #0x2, [W15]
0009B8  3A008F     BRA NZ, 0xAD8
283:                   {
284:                       // Phase A //////
285:                       // Present Sin = 0 and loaded next value, DecaySin
286:                       // Polarisation negative
287:                       //MST.MicStep = MicStepArray[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch];
288:                       if(MotorRight.Direction)
0009BA  804924     MOV 0x924, W4
0009BC  520FE0     SUB W4, #0x0, [W15]
0009BE  320013     BRA Z, 0x9E6
289:                       {
290:                           if(OC7CONbits.OCM != 0b110)
0009C0  800D44     MOV OC7CON, W4
0009C2  620267     AND W4, #0x7, W4
0009C4  520FE6     SUB W4, #0x6, [W15]
0009C6  320005     BRA Z, 0x9D2
291:                           OC7CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
0009C8  800D44     MOV OC7CON, W4
0009CA  A10004     BCLR W4, #0
0009CC  A01004     BSET W4, #1
0009CE  A02004     BSET W4, #2
0009D0  880D44     MOV W4, OC7CON
292:                           if(OC8CONbits.OCM != 0b101)
0009D2  800D74     MOV OC8CON, W4
0009D4  620267     AND W4, #0x7, W4
0009D6  520FE5     SUB W4, #0x5, [W15]
0009D8  320018     BRA Z, 0xA0A
293:                           OC8CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
0009DA  800D74     MOV OC8CON, W4
0009DC  A00004     BSET W4, #0
0009DE  A11004     BCLR W4, #1
0009E0  A02004     BSET W4, #2
0009E2  880D74     MOV W4, OC8CON
0009E4  370012     BRA 0xA0A
294:                       }
295:                       else
296:                       {
297:                           if(OC6CONbits.OCM != 0b101)
0009E6  800D14     MOV OC6CON, W4
0009E8  620267     AND W4, #0x7, W4
0009EA  520FE5     SUB W4, #0x5, [W15]
0009EC  320005     BRA Z, 0x9F8
298:                           OC6CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
0009EE  800D14     MOV OC6CON, W4
0009F0  A00004     BSET W4, #0
0009F2  A11004     BCLR W4, #1
0009F4  A02004     BSET W4, #2
0009F6  880D14     MOV W4, OC6CON
299:                           if(OC5CONbits.OCM != 0b110)
0009F8  800CE4     MOV OC5CON, W4
0009FA  620267     AND W4, #0x7, W4
0009FC  520FE6     SUB W4, #0x6, [W15]
0009FE  320005     BRA Z, 0xA0A
300:                           OC5CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000A00  800CE4     MOV OC5CON, W4
000A02  A10004     BCLR W4, #0
000A04  A01004     BSET W4, #1
000A06  A02004     BSET W4, #2
000A08  880CE4     MOV W4, OC5CON
301:                       }
302:                       OC7RS = PidExec(ADCCSARight, Sin90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSAR);
000A0A  8048A5     MOV 0x914, W5
000A0C  842ED4     MOV 0x85DA, W4
000A0E  090011     REPEAT #0x11
000A10  D80284     DIV.SW W5, W4
000A12  780201     MOV W1, W4
000A14  780284     MOV W4, W5
000A16  8048B4     MOV 0x916, W4
000A18  428204     ADD W5, W4, W4
000A1A  420284     ADD W4, W4, W5
000A1C  285AC4     MOV #0x85AC, W4
000A1E  428204     ADD W5, W4, W4
000A20  780294     MOV [W4], W5
000A22  8044E4     MOV ADCCSARight, W4
000A24  208002     MOV #0x800, W2
000A26  780085     MOV W5, W1
000A28  780004     MOV W4, W0
000A2A  0703EE     RCALL _PidExec
000A2C  780200     MOV W0, W4
000A2E  880D24     MOV W4, OC7RS
303:                       MotorRight.Oc84r = OC7RS;
000A30  800D24     MOV OC7RS, W4
000A32  884994     MOV W4, 0x932
304:                       if((MotorRight.Oc84r + 10) >= PR2)
000A34  804994     MOV 0x932, W4
000A36  4202EA     ADD W4, #0xA, W5
000A38  800864     MOV PR2, W4
000A3A  528F84     SUB W5, W4, [W15]
000A3C  390006     BRA NC, 0xA4A
305:                           OC8CONbits.OCM = 0b000;                 // Disable fast deccay
000A3E  800D74     MOV OC8CON, W4
000A40  A10004     BCLR W4, #0
000A42  A11004     BCLR W4, #1
000A44  A12004     BCLR W4, #2
000A46  880D74     MOV W4, OC8CON
000A48  370005     BRA 0xA54
306:                       else OC8CONbits.OCM = 0b101;
000A4A  800D74     MOV OC8CON, W4
000A4C  A00004     BSET W4, #0
000A4E  A11004     BCLR W4, #1
000A50  A02004     BSET W4, #2
000A52  880D74     MOV W4, OC8CON
307:                       MotorRight.Oc84rs = 2 + MotorRight.Oc84r + (PR2 - MotorRight.Oc84r) * MotorRight.DecaySin / 100;
000A54  804996     MOV 0x932, W6
000A56  800865     MOV PR2, W5
000A58  804994     MOV 0x932, W4
000A5A  528284     SUB W5, W4, W5
000A5C  804934     MOV 0x926, W4
000A5E  B9AA04     MUL.SS W5, W4, W4
000A60  780284     MOV W4, W5
000A62  200644     MOV #0x64, W4
000A64  090011     REPEAT #0x11
000A66  D88284     DIV.UW W5, W4
000A68  780200     MOV W0, W4
000A6A  430204     ADD W6, W4, W4
000A6C  E88204     INC2 W4, W4
000A6E  884954     MOV W4, 0x92A
308:                       // Phase B //////
309:                       // Present Cos = 1 and loaded next value, DecayCos
310:                       OC5RS = PidExec(ADCCSBRight, Cos90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSBR);
000A70  8048A5     MOV 0x914, W5
000A72  842ED4     MOV 0x85DA, W4
000A74  090011     REPEAT #0x11
000A76  D80284     DIV.SW W5, W4
000A78  780201     MOV W1, W4
000A7A  780284     MOV W4, W5
000A7C  8048B4     MOV 0x916, W4
000A7E  428204     ADD W5, W4, W4
000A80  420284     ADD W4, W4, W5
000A82  2858A4     MOV #0x858A, W4
000A84  428204     ADD W5, W4, W4
000A86  780294     MOV [W4], W5
000A88  8044F4     MOV ADCCSBRight, W4
000A8A  208182     MOV #0x818, W2
000A8C  780085     MOV W5, W1
000A8E  780004     MOV W4, W0
000A90  0703BB     RCALL _PidExec
000A92  780200     MOV W0, W4
000A94  880CC4     MOV W4, OC5RS
311:                       MotorRight.Oc62r = OC5RS;
000A96  800CC4     MOV OC5RS, W4
000A98  8849B4     MOV W4, 0x936
312:                       if((MotorRight.Oc62r + 10) >= PR2)
000A9A  8049B4     MOV 0x936, W4
000A9C  4202EA     ADD W4, #0xA, W5
000A9E  800864     MOV PR2, W4
000AA0  528F84     SUB W5, W4, [W15]
000AA2  390006     BRA NC, 0xAB0
313:                           OC6CONbits.OCM = 0b000;                 // Disable fast deccay
000AA4  800D14     MOV OC6CON, W4
000AA6  A10004     BCLR W4, #0
000AA8  A11004     BCLR W4, #1
000AAA  A12004     BCLR W4, #2
000AAC  880D14     MOV W4, OC6CON
000AAE  370005     BRA 0xABA
314:                       else OC6CONbits.OCM = 0b101;
000AB0  800D14     MOV OC6CON, W4
000AB2  A00004     BSET W4, #0
000AB4  A11004     BCLR W4, #1
000AB6  A02004     BSET W4, #2
000AB8  880D14     MOV W4, OC6CON
315:                       MotorRight.Oc62rs = 2 + MotorRight.Oc62r + (PR2 - MotorRight.Oc62r) * MotorRight.DecayCos / 100;
000ABA  8049B6     MOV 0x936, W6
000ABC  800865     MOV PR2, W5
000ABE  8049B4     MOV 0x936, W4
000AC0  528284     SUB W5, W4, W5
000AC2  804944     MOV 0x928, W4
000AC4  B9AA04     MUL.SS W5, W4, W4
000AC6  780284     MOV W4, W5
000AC8  200644     MOV #0x64, W4
000ACA  090011     REPEAT #0x11
000ACC  D88284     DIV.UW W5, W4
000ACE  780200     MOV W0, W4
000AD0  430204     ADD W6, W4, W4
000AD2  E88204     INC2 W4, W4
000AD4  884974     MOV W4, 0x92E
000AD6  370095     BRA 0xC02
316:                   }
317:                   else if(MotorRight.MicStep/MICSTEPS == 3)					// sin <0, cos >0
000AD8  8048A5     MOV 0x914, W5
000ADA  842ED4     MOV 0x85DA, W4
000ADC  090011     REPEAT #0x11
000ADE  D80284     DIV.SW W5, W4
000AE0  780200     MOV W0, W4
000AE2  520FE3     SUB W4, #0x3, [W15]
000AE4  3A008E     BRA NZ, 0xC02
318:                   {
319:                       // Phase A //////
320:                       // Present Cos = 1 and loaded next value, DecayCos
321:                       //MST.MicStep = MicStepArray[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch];
322:                       if(MotorRight.Direction)
000AE6  804924     MOV 0x924, W4
000AE8  520FE0     SUB W4, #0x0, [W15]
000AEA  320013     BRA Z, 0xB12
323:                       {
324:                           if(OC6CONbits.OCM != 0b110)
000AEC  800D14     MOV OC6CON, W4
000AEE  620267     AND W4, #0x7, W4
000AF0  520FE6     SUB W4, #0x6, [W15]
000AF2  320005     BRA Z, 0xAFE
325:                           OC6CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000AF4  800D14     MOV OC6CON, W4
000AF6  A10004     BCLR W4, #0
000AF8  A01004     BSET W4, #1
000AFA  A02004     BSET W4, #2
000AFC  880D14     MOV W4, OC6CON
326:                           if(OC5CONbits.OCM != 0b101)
000AFE  800CE4     MOV OC5CON, W4
000B00  620267     AND W4, #0x7, W4
000B02  520FE5     SUB W4, #0x5, [W15]
000B04  320018     BRA Z, 0xB36
327:                           OC5CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
000B06  800CE4     MOV OC5CON, W4
000B08  A00004     BSET W4, #0
000B0A  A11004     BCLR W4, #1
000B0C  A02004     BSET W4, #2
000B0E  880CE4     MOV W4, OC5CON
000B10  370012     BRA 0xB36
328:                       }
329:                       else
330:                       {
331:                           if(OC7CONbits.OCM != 0b110)
000B12  800D44     MOV OC7CON, W4
000B14  620267     AND W4, #0x7, W4
000B16  520FE6     SUB W4, #0x6, [W15]
000B18  320005     BRA Z, 0xB24
332:                           OC7CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000B1A  800D44     MOV OC7CON, W4
000B1C  A10004     BCLR W4, #0
000B1E  A01004     BSET W4, #1
000B20  A02004     BSET W4, #2
000B22  880D44     MOV W4, OC7CON
333:                           if(OC8CONbits.OCM != 0b101)
000B24  800D74     MOV OC8CON, W4
000B26  620267     AND W4, #0x7, W4
000B28  520FE5     SUB W4, #0x5, [W15]
000B2A  320005     BRA Z, 0xB36
334:                           OC8CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
000B2C  800D74     MOV OC8CON, W4
000B2E  A00004     BSET W4, #0
000B30  A11004     BCLR W4, #1
000B32  A02004     BSET W4, #2
000B34  880D74     MOV W4, OC8CON
335:                       }
336:                       OC7RS = PidExec(ADCCSARight, Cos90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSAR);
000B36  8048A5     MOV 0x914, W5
000B38  842ED4     MOV 0x85DA, W4
000B3A  090011     REPEAT #0x11
000B3C  D80284     DIV.SW W5, W4
000B3E  780201     MOV W1, W4
000B40  780284     MOV W4, W5
000B42  8048B4     MOV 0x916, W4
000B44  428204     ADD W5, W4, W4
000B46  420284     ADD W4, W4, W5
000B48  2858A4     MOV #0x858A, W4
000B4A  428204     ADD W5, W4, W4
000B4C  780294     MOV [W4], W5
000B4E  8044E4     MOV ADCCSARight, W4
000B50  208002     MOV #0x800, W2
000B52  780085     MOV W5, W1
000B54  780004     MOV W4, W0
000B56  070358     RCALL _PidExec
000B58  780200     MOV W0, W4
000B5A  880D24     MOV W4, OC7RS
337:                       MotorRight.Oc84r = OC7RS;
000B5C  800D24     MOV OC7RS, W4
000B5E  884994     MOV W4, 0x932
338:                       if((MotorRight.Oc84r + 10) >= PR2)
000B60  804994     MOV 0x932, W4
000B62  4202EA     ADD W4, #0xA, W5
000B64  800864     MOV PR2, W4
000B66  528F84     SUB W5, W4, [W15]
000B68  390006     BRA NC, 0xB76
339:                           OC8CONbits.OCM = 0b000;                 // Disable fast deccay
000B6A  800D74     MOV OC8CON, W4
000B6C  A10004     BCLR W4, #0
000B6E  A11004     BCLR W4, #1
000B70  A12004     BCLR W4, #2
000B72  880D74     MOV W4, OC8CON
000B74  370005     BRA 0xB80
340:                       else OC8CONbits.OCM = 0b101;
000B76  800D74     MOV OC8CON, W4
000B78  A00004     BSET W4, #0
000B7A  A11004     BCLR W4, #1
000B7C  A02004     BSET W4, #2
000B7E  880D74     MOV W4, OC8CON
341:                       MotorRight.Oc84rs = 2 + MotorRight.Oc84r + (PR2 - MotorRight.Oc84r) * MotorRight.DecayCos / 100;
000B80  804996     MOV 0x932, W6
000B82  800865     MOV PR2, W5
000B84  804994     MOV 0x932, W4
000B86  528284     SUB W5, W4, W5
000B88  804944     MOV 0x928, W4
000B8A  B9AA04     MUL.SS W5, W4, W4
000B8C  780284     MOV W4, W5
000B8E  200644     MOV #0x64, W4
000B90  090011     REPEAT #0x11
000B92  D88284     DIV.UW W5, W4
000B94  780200     MOV W0, W4
000B96  430204     ADD W6, W4, W4
000B98  E88204     INC2 W4, W4
000B9A  884954     MOV W4, 0x92A
342:                       // Phase B //////
343:                       // Present Sin = 0 and loaded next value, DecaySin
344:                       // Polarisation positive
345:               
346:                       OC6RS = PidExec(ADCCSBRight, Sin90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSBR);
000B9C  8048A5     MOV 0x914, W5
000B9E  842ED4     MOV 0x85DA, W4
000BA0  090011     REPEAT #0x11
000BA2  D80284     DIV.SW W5, W4
000BA4  780201     MOV W1, W4
000BA6  780284     MOV W4, W5
000BA8  8048B4     MOV 0x916, W4
000BAA  428204     ADD W5, W4, W4
000BAC  420284     ADD W4, W4, W5
000BAE  285AC4     MOV #0x85AC, W4
000BB0  428204     ADD W5, W4, W4
000BB2  780294     MOV [W4], W5
000BB4  8044F4     MOV ADCCSBRight, W4
000BB6  208182     MOV #0x818, W2
000BB8  780085     MOV W5, W1
000BBA  780004     MOV W4, W0
000BBC  070325     RCALL _PidExec
000BBE  780200     MOV W0, W4
000BC0  880CF4     MOV W4, OC6RS
347:                       MotorRight.Oc51r = OC6RS;
000BC2  800CF4     MOV OC6RS, W4
000BC4  8849C4     MOV W4, 0x938
348:                       if((MotorRight.Oc51r + 10) >= PR2)
000BC6  8049C4     MOV 0x938, W4
000BC8  4202EA     ADD W4, #0xA, W5
000BCA  800864     MOV PR2, W4
000BCC  528F84     SUB W5, W4, [W15]
000BCE  390006     BRA NC, 0xBDC
349:                           OC5CONbits.OCM = 0b000;                 // Disable fast deccay
000BD0  800CE4     MOV OC5CON, W4
000BD2  A10004     BCLR W4, #0
000BD4  A11004     BCLR W4, #1
000BD6  A12004     BCLR W4, #2
000BD8  880CE4     MOV W4, OC5CON
000BDA  370005     BRA 0xBE6
350:                       else OC5CONbits.OCM = 0b101;
000BDC  800CE4     MOV OC5CON, W4
000BDE  A00004     BSET W4, #0
000BE0  A11004     BCLR W4, #1
000BE2  A02004     BSET W4, #2
000BE4  880CE4     MOV W4, OC5CON
351:                       MotorRight.Oc51rs = 2 + MotorRight.Oc51r + (PR2 - MotorRight.Oc51r) *  MotorRight.DecaySin / 100;
000BE6  8049C6     MOV 0x938, W6
000BE8  800865     MOV PR2, W5
000BEA  8049C4     MOV 0x938, W4
000BEC  528284     SUB W5, W4, W5
000BEE  804934     MOV 0x926, W4
000BF0  B9AA04     MUL.SS W5, W4, W4
000BF2  780284     MOV W4, W5
000BF4  200644     MOV #0x64, W4
000BF6  090011     REPEAT #0x11
000BF8  D88284     DIV.UW W5, W4
000BFA  780200     MOV W0, W4
000BFC  430204     ADD W6, W4, W4
000BFE  E88204     INC2 W4, W4
000C00  884984     MOV W4, 0x930
352:                   }
353:                   MotorRight.StepPresc++;
000C02  804894     MOV 0x912, W4
000C04  E80204     INC W4, W4
000C06  884894     MOV W4, 0x912
354:                   if(MotorRight.StepPresc >= MotorRight.StepPrescValLatch)
000C08  804895     MOV 0x912, W5
000C0A  8048E4     MOV 0x91C, W4
000C0C  528F84     SUB W5, W4, [W15]
000C0E  350025     BRA LT, 0xC5A
355:                   {
356:                           MotorRight.StepPresc = 0;
000C10  EB0200     CLR W4
000C12  884894     MOV W4, 0x912
357:                           if(MotorRight.Direction == 1)
000C14  804924     MOV 0x924, W4
000C16  520FE1     SUB W4, #0x1, [W15]
000C18  3A0010     BRA NZ, 0xC3A
358:                           {
359:                               MotorRight.MicStep += MotorRight.StepIncLatch;
000C1A  8048A5     MOV 0x914, W5
000C1C  8048B4     MOV 0x916, W4
000C1E  428204     ADD W5, W4, W4
000C20  8848A4     MOV W4, 0x914
360:                               if(MotorRight.MicStep >= MICSTEPS * 4)
000C22  8048A5     MOV 0x914, W5
000C24  842ED4     MOV 0x85DA, W4
000C26  DD2242     SL W4, #2, W4
000C28  528F84     SUB W5, W4, [W15]
000C2A  350017     BRA LT, 0xC5A
361:                               {
362:                                   MotorRight.MicStep = 0;
000C2C  EB0200     CLR W4
000C2E  8848A4     MOV W4, 0x914
363:                                   MotorRight.StepIncLatch = MotorRight.StepInc;
000C30  8048C4     MOV 0x918, W4
000C32  8848B4     MOV W4, 0x916
364:                                   MotorRight.StepPrescValLatch = MotorRight.StepPrescVal;
000C34  8048D4     MOV 0x91A, W4
000C36  8848E4     MOV W4, 0x91C
000C38  370010     BRA 0xC5A
365:                               }
366:                           }
367:                           else
368:                           {
369:                               MotorRight.MicStep -= MotorRight.StepIncLatch;
000C3A  8048A5     MOV 0x914, W5
000C3C  8048B4     MOV 0x916, W4
000C3E  528204     SUB W5, W4, W4
000C40  8848A4     MOV W4, 0x914
370:                               if(MotorRight.MicStep < 0)
000C42  8048A4     MOV 0x914, W4
000C44  520FE0     SUB W4, #0x0, [W15]
000C46  3D0009     BRA GE, 0xC5A
371:                               {
372:                                   MotorRight.StepIncLatch = MotorRight.StepInc;
000C48  8048C4     MOV 0x918, W4
000C4A  8848B4     MOV W4, 0x916
373:                                   MotorRight.StepPrescValLatch = MotorRight.StepPrescVal;
000C4C  8048D4     MOV 0x91A, W4
000C4E  8848E4     MOV W4, 0x91C
374:                                   MotorRight.MicStep = MICSTEPS * 4 - MotorRight.StepIncLatch;
000C50  842ED4     MOV 0x85DA, W4
000C52  DD22C2     SL W4, #2, W5
000C54  8048B4     MOV 0x916, W4
000C56  528204     SUB W5, W4, W4
000C58  8848A4     MOV W4, 0x914
375:               
376:                               }
377:                           }
378:                   }
379:               }
000C5A  FA8000     ULNK
000C5C  060000     RETURN
380:               //inline void MotorLeftDriver(struct Motor* motor)
381:               //{
382:               //    static unsigned int Oc84rs = 0;
383:               //    static unsigned int Oc73rs = 0;
384:               //    static unsigned int Oc62rs = 0;
385:               //    static unsigned int Oc51rs = 0;
386:               //    static unsigned int Oc84r = 0;
387:               //    static unsigned int Oc73r = 0;
388:               //    static unsigned int Oc62r = 0;
389:               //    static unsigned int Oc51r = 0;
390:               //
391:               //    if(MotorLeft.MicStep/MICSTEPS == 0)			// sin >0, cos >0
392:               //    {
393:               //        // Phase A //////
394:               //        // Present Sin = 0 and loaded next value, DecaySin
395:               //        // Polarisation positive
396:               //        //MST.MicStep = MicStepArray[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
397:               //        if(MotorLeft.Direction)
398:               //        {
399:               //             if(OC4CONbits.OCM != 0b110)
400:               //             OC4CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
401:               //             if(OC3CONbits.OCM != 0b101)
402:               //             OC3CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
403:               //        }
404:               //        else
405:               //        {
406:               //            if(OC2CONbits.OCM != 0b110)
407:               //            OC2CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
408:               //            if(OC1CONbits.OCM != 0b101)
409:               //            OC1CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
410:               //        }
411:               //        OC4RS = Sin90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
412:               //        OC3R = Oc73r;
413:               //        OC3RS = Oc73rs;
414:               //        Oc73r = OC4RS;
415:               //        if((Oc73r + 10) >= PR2)
416:               //            OC3CONbits.OCM = 0b000;                 // Disable fast deccay
417:               //        else OC3CONbits.OCM = 0b101;
418:               //        Oc73rs = 2 + Oc73r + (PR2 - Oc73r) * MotorLeft.DecaySin / 100;
419:               //        // Phase B //////
420:               //        // Present Cos = 1 and loaded next value, DecayCos
421:               //        OC2RS = Cos90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
422:               //        OC1R = Oc51r;
423:               //        OC1RS = Oc51rs;
424:               //        Oc51r = OC2RS;
425:               //        if((Oc51r + 10) >= PR2)
426:               //            OC1CONbits.OCM = 0b000;                 // Disable fast deccay
427:               //        else OC1CONbits.OCM = 0b101;
428:               //        Oc51rs = 2 + Oc51r + (PR2 - Oc51r) * MotorLeft.DecayCos / 100;
429:               //    }
430:               //    else if(MotorLeft.MicStep/MICSTEPS == 1)		// sin >0, cos <0
431:               //    {
432:               //        // Phase A //////
433:               //        // Present Cos = 1 and loaded next value, DecayCos
434:               //        //MST.MicStep = MicStepArray[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
435:               //        if(MotorLeft.Direction)
436:               //        {
437:               //            if(OC2CONbits.OCM != 0b101)
438:               //            OC2CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
439:               //            if(OC1CONbits.OCM != 0b110)
440:               //            OC1CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
441:               //        }
442:               //        else
443:               //        {
444:               //             if(OC4CONbits.OCM != 0b110)
445:               //             OC4CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
446:               //             if(OC3CONbits.OCM != 0b101)
447:               //             OC3CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
448:               //        }
449:               //        OC4RS = Cos90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
450:               //        OC3R = Oc73r;
451:               //        OC3RS = Oc73rs;
452:               //        Oc73r = OC4RS;
453:               //        if((Oc73r + 10) >= PR2)
454:               //            OC3CONbits.OCM = 0b000;                 // Disable fast deccay
455:               //        else OC3CONbits.OCM = 0b101;
456:               //        Oc73rs = 2 + Oc73r + (PR2 - Oc73r) * MotorLeft.DecayCos / 100;
457:               //        // Phase B //////
458:               //        // Present Sin = 0 and loaded next value, DecaySin
459:               //        // Polarisation negative
460:               //
461:               //        OC1RS = Sin90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
462:               //        OC2R = Oc62r;
463:               //        OC2RS = Oc62rs;
464:               //        Oc62r = OC1RS;
465:               //        if((Oc62r + 10) >= PR2)
466:               //            OC2CONbits.OCM = 0b000;                 // Disable fast deccay
467:               //        else OC2CONbits.OCM = 0b101;
468:               //        Oc62rs = 2 + Oc62r + (PR2 - Oc62r) * MotorLeft.DecaySin / 100;
469:               //    }
470:               //    else if(MotorLeft.MicStep/MICSTEPS == 2)		// sin <0, cos <0
471:               //    {
472:               //        // Phase A //////
473:               //        // Present Sin = 0 and loaded next value, DecaySin
474:               //        // Polarisation negative
475:               //        //MST.MicStep = MicStepArray[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
476:               //        if(MotorLeft.Direction)
477:               //        {
478:               //            if(OC3CONbits.OCM != 0b110)
479:               //            OC3CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
480:               //            if(OC4CONbits.OCM != 0b101)
481:               //            OC4CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
482:               //        }
483:               //        else
484:               //        {
485:               //            if(OC2CONbits.OCM != 0b101)
486:               //            OC2CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
487:               //            if(OC1CONbits.OCM != 0b110)
488:               //            OC1CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
489:               //        }
490:               //        OC3RS = Sin90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
491:               //        OC4R = Oc84r;
492:               //        OC4RS = Oc84rs;
493:               //        Oc84r = OC3RS;
494:               //        if((Oc84r + 10) >= PR2)
495:               //            OC4CONbits.OCM = 0b000;                 // Disable fast deccay
496:               //        else OC4CONbits.OCM = 0b101;
497:               //        Oc84rs = 2 + Oc84r + (PR2 - Oc84r) * MotorLeft.DecaySin / 100;
498:               //        // Phase B //////
499:               //        // Present Cos = 1 and loaded next value, DecayCos
500:               //        OC1RS = Cos90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
501:               //        OC2R = Oc62r;
502:               //        OC2RS = Oc62rs;
503:               //        Oc62r = OC1RS;
504:               //        if((Oc62r + 10) >= PR2)
505:               //            OC2CONbits.OCM = 0b000;                 // Disable fast deccay
506:               //        else OC2CONbits.OCM = 0b101;
507:               //        Oc62rs = 2 + Oc62r + (PR2 - Oc62r) * MotorLeft.DecayCos / 100;
508:               //    }
509:               //    else if(MotorLeft.MicStep/MICSTEPS == 3)					// sin <0, cos >0
510:               //    {
511:               //        // Phase A //////
512:               //        // Present Cos = 1 and loaded next value, DecayCos
513:               //        //MST.MicStep = MicStepArray[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
514:               //        if(MotorLeft.Direction)
515:               //        {
516:               //            if(OC2CONbits.OCM != 0b110)
517:               //            OC2CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
518:               //            if(OC1CONbits.OCM != 0b101)
519:               //            OC1CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
520:               //        }
521:               //        else
522:               //        {
523:               //            if(OC3CONbits.OCM != 0b110)
524:               //            OC3CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
525:               //            if(OC4CONbits.OCM != 0b101)
526:               //            OC4CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
527:               //        }
528:               //        OC3RS = Cos90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
529:               //        OC4R = Oc84r;
530:               //        OC4RS = Oc84rs;
531:               //        Oc84r = OC3RS;
532:               //        if((Oc84r + 10) >= PR2)
533:               //            OC4CONbits.OCM = 0b000;                 // Disable fast deccay
534:               //        else OC4CONbits.OCM = 0b101;
535:               //        Oc84rs = 2 + Oc84r + (PR2 - Oc84r) * MotorLeft.DecayCos / 100;
536:               //        // Phase B //////
537:               //        // Present Sin = 0 and loaded next value, DecaySin
538:               //        // Polarisation positive
539:               //
540:               //        OC2RS = Sin90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
541:               //        OC1R = Oc51r;
542:               //        OC1RS = Oc51rs;
543:               //        Oc51r = OC2RS;
544:               //        if((Oc51r + 10) >= PR2)
545:               //            OC1CONbits.OCM = 0b000;                 // Disable fast deccay
546:               //        else OC1CONbits.OCM = 0b101;
547:               //        Oc51rs = 2 + Oc51r + (PR2 - Oc51r) *  MotorLeft.DecaySin / 100;
548:               //    }
549:               //    MotorLeft.StepPresc++;
550:               //    if(MotorLeft.StepPresc >= MotorLeft.StepPrescValLatch)
551:               //    {
552:               //            MotorLeft.StepPresc = 0;
553:               //            if(MotorLeft.Direction == 1)
554:               //            {
555:               //                MotorLeft.MicStep += MotorLeft.StepIncLatch;
556:               //                if(MotorLeft.MicStep >= MICSTEPS * 4)
557:               //                {
558:               //                    MotorLeft.MicStep = 0;
559:               //                    MotorLeft.StepIncLatch = MotorLeft.StepInc;
560:               //                    MotorLeft.StepPrescValLatch = MotorLeft.StepPrescVal;
561:               //                }
562:               //            }
563:               //            else
564:               //            {
565:               //                MotorLeft.MicStep -= MotorLeft.StepIncLatch;
566:               //                if(MotorLeft.MicStep < 0)
567:               //                {
568:               //                    MotorLeft.StepIncLatch = MotorLeft.StepInc;
569:               //                    MotorLeft.StepPrescValLatch = MotorLeft.StepPrescVal;
570:               //                    MotorLeft.MicStep = MICSTEPS * 4 - MotorLeft.StepIncLatch;
571:               //
572:               //                }
573:               //            }
574:               //    }
575:               //}
576:               void MotorInputUpdate(struct Motor* motor)
577:               {
000C5E  FA0002     LNK #0x2
000C60  780F00     MOV W0, [W14]
578:                   motor->StepInc = SPEED_CURVE[motor->SpeedAbs][1];
000C62  78021E     MOV [W14], W4
000C64  900264     MOV [W4+12], W4
000C66  B92266     MUL.SU W4, #6, W4
000C68  780204     MOV W4, W4
000C6A  E88204     INC2 W4, W4
000C6C  780104     MOV W4, W2
000C6E  DEA24F     ASR W4, #15, W4
000C70  780184     MOV W4, W3
000C72  2019E4     MOV #0x19E, W4
000C74  200005     MOV #0x0, W5
000C76  410204     ADD W2, W4, W4
000C78  498285     ADDC W3, W5, W5
000C7A  8001A0     MOV PSVPAG, W0
000C7C  A4F004     BTSTS.C W4, #15
000C7E  D28285     RLC W5, W5
000C80  8801A5     MOV W5, PSVPAG
000C82  780214     MOV [W4], W4
000C84  8801A0     MOV W0, PSVPAG
000C86  780284     MOV W4, W5
000C88  78021E     MOV [W14], W4
000C8A  980235     MOV W5, [W4+6]
579:                   motor->StepPrescVal = SPEED_CURVE[motor->SpeedAbs][2];
000C8C  78021E     MOV [W14], W4
000C8E  900264     MOV [W4+12], W4
000C90  B92266     MUL.SU W4, #6, W4
000C92  780204     MOV W4, W4
000C94  420264     ADD W4, #0x4, W4
000C96  780304     MOV W4, W6
000C98  DEA24F     ASR W4, #15, W4
000C9A  780384     MOV W4, W7
000C9C  2019E4     MOV #0x19E, W4
000C9E  200005     MOV #0x0, W5
000CA0  430204     ADD W6, W4, W4
000CA2  4B8285     ADDC W7, W5, W5
000CA4  8001A6     MOV PSVPAG, W6
000CA6  A4F004     BTSTS.C W4, #15
000CA8  D28285     RLC W5, W5
000CAA  8801A5     MOV W5, PSVPAG
000CAC  780214     MOV [W4], W4
000CAE  8801A6     MOV W6, PSVPAG
000CB0  780284     MOV W4, W5
000CB2  78021E     MOV [W14], W4
000CB4  980245     MOV W5, [W4+8]
580:               
581:                   SpeedSlewRate(motor);
000CB6  78001E     MOV [W14], W0
000CB8  07FC92     RCALL SpeedSlewRate
582:                   
583:                   if(motor->Speed > 0)
000CBA  78021E     MOV [W14], W4
000CBC  900274     MOV [W4+14], W4
000CBE  520FE0     SUB W4, #0x0, [W15]
000CC0  340017     BRA LE, 0xCF0
584:                   {
585:                       if(motor->SpeedAbs == 0)
000CC2  78021E     MOV [W14], W4
000CC4  900264     MOV [W4+12], W4
000CC6  520FE0     SUB W4, #0x0, [W15]
000CC8  3A000B     BRA NZ, 0xCE0
586:                       {
587:                           motor->StepIncLatch = SPEED_CURVE[1][1];
000CCA  201A64     MOV #0x1A6, W4
000CCC  200005     MOV #0x0, W5
000CCE  8001A6     MOV PSVPAG, W6
000CD0  A4F004     BTSTS.C W4, #15
000CD2  D28285     RLC W5, W5
000CD4  8801A5     MOV W5, PSVPAG
000CD6  780214     MOV [W4], W4
000CD8  8801A6     MOV W6, PSVPAG
000CDA  780284     MOV W4, W5
000CDC  78021E     MOV [W14], W4
000CDE  980225     MOV W5, [W4+4]
588:                       }
589:                       motor->SpeedAbs = motor->Speed;
000CE0  78021E     MOV [W14], W4
000CE2  9002F4     MOV [W4+14], W5
000CE4  78021E     MOV [W14], W4
000CE6  980265     MOV W5, [W4+12]
590:                       motor->Direction = 1;
000CE8  78021E     MOV [W14], W4
000CEA  200015     MOV #0x1, W5
000CEC  980A15     MOV W5, [W4+18]
000CEE  370022     BRA 0xD34
591:               
592:                   }
593:                   else if(motor->Speed < 0)
000CF0  78021E     MOV [W14], W4
000CF2  900274     MOV [W4+14], W4
000CF4  520FE0     SUB W4, #0x0, [W15]
000CF6  3D0018     BRA GE, 0xD28
594:                   {
595:                       if(motor->SpeedAbs == 0)
000CF8  78021E     MOV [W14], W4
000CFA  900264     MOV [W4+12], W4
000CFC  520FE0     SUB W4, #0x0, [W15]
000CFE  3A000B     BRA NZ, 0xD16
596:                       {
597:                           motor->StepIncLatch = SPEED_CURVE[1][1];
000D00  201A64     MOV #0x1A6, W4
000D02  200005     MOV #0x0, W5
000D04  8001A6     MOV PSVPAG, W6
000D06  A4F004     BTSTS.C W4, #15
000D08  D28285     RLC W5, W5
000D0A  8801A5     MOV W5, PSVPAG
000D0C  780214     MOV [W4], W4
000D0E  8801A6     MOV W6, PSVPAG
000D10  780284     MOV W4, W5
000D12  78021E     MOV [W14], W4
000D14  980225     MOV W5, [W4+4]
598:                       }
599:                       motor->SpeedAbs = -(motor->Speed);
000D16  78021E     MOV [W14], W4
000D18  900274     MOV [W4+14], W4
000D1A  EA0284     NEG W4, W5
000D1C  78021E     MOV [W14], W4
000D1E  980265     MOV W5, [W4+12]
600:                       motor->Direction = 0;
000D20  78021E     MOV [W14], W4
000D22  EB0280     CLR W5
000D24  980A15     MOV W5, [W4+18]
000D26  370006     BRA 0xD34
601:                    }
602:                    else
603:                    {
604:                       motor->SpeedAbs = 0;
000D28  78021E     MOV [W14], W4
000D2A  EB0280     CLR W5
000D2C  980265     MOV W5, [W4+12]
605:                       motor->StepIncLatch = 0;
000D2E  78021E     MOV [W14], W4
000D30  EB0280     CLR W5
000D32  980225     MOV W5, [W4+4]
606:                    }
607:               }
000D34  FA8000     ULNK
000D36  060000     RETURN
608:               void MotorsInputUpdate(void)
609:               {
000D38  FA0000     LNK #0x0
610:                   MotorInputUpdate(&MotorRight);
000D3A  209120     MOV #0x912, W0
000D3C  07FF90     RCALL MotorInputUpdate
611:                   MotorInputUpdate(&MotorLeft);
000D3E  208EA0     MOV #0x8EA, W0
000D40  07FF8E     RCALL MotorInputUpdate
612:               }
000D42  FA8000     ULNK
000D44  060000     RETURN
613:               void MotorsInit(void)
614:               {
000D46  FA0000     LNK #0x0
615:                   //////////////// MicStepArray Init  /////////////////////////////////////////////////////////////////////////
616:               //	int i;
617:               //	for(i = 0; i <= MICSTEPS; i++)
618:               //	{
619:               //		Sin90[i] = (unsigned int)((float)T2_PR2 * sin((float)i/(float)(MICSTEPS) * (PI/2)));
620:               //		Cos90[i] = (unsigned int)((float)T2_PR2 * cos((float)i/(float)(MICSTEPS) * (PI/2)));
621:               //	}
622:                   //////////////////////////////////////////////////////////////////////////////////////////////////////
623:               	/////////////// Motor Control Pins ///////////////////////////////////////////////////////////////////////////////
624:               	/////////////// Motor Right ///////////////////
625:                       //  ENA -   RF1
626:                       //  In1 -   OC8/CN16/RD7
627:                       //  In2 -   OC7/CN15/RD6
628:                       //  ENB -   RF0
629:                       //  In3 -   OC6/CN14/RD5
630:                       //  In4 -   OC5/CN13/RD4
631:                       /////////////// Motor Left ///////////////////
632:                       //  ENA -   RD13
633:                       //  In1 -   OC4/RD3
634:                       //  In2 -   OC3/RD2
635:                       //  ENB -   RD12
636:                       //  In3 -   EMUD2/OC2/RD1
637:                       //  In4 -   EMUC2/OC1/RD0
638:                       ///////////////////////////////////////////////
639:               
640:                   TRISFbits.TRISF1 = 0;		// Enable Motor driver pins as outputs
000D48  A922DE     BCLR TRISF, #1
641:               	TRISFbits.TRISF0 = 0;		//
000D4A  A902DE     BCLR TRISF, #0
642:               	TRISDbits.TRISD13 = 0;		//
000D4C  A9A2D3     BCLR 0x2D3, #5
643:               	TRISDbits.TRISD12 = 0;		//
000D4E  A982D3     BCLR 0x2D3, #4
644:               
645:                       PORTFbits.RF1 = 1;              // Enable Motor drivers
000D50  A822E0     BSET PORTF, #1
646:                      // PORTFbits.RF0 = 1;              //
647:                       PORTF |= 3;
000D52  801704     MOV PORTF, W4
000D54  B30034     IOR #0x3, W4
000D56  881704     MOV W4, PORTF
648:                       PORTDbits.RD13 = 1;             //
000D58  A8A2D5     BSET 0x2D5, #5
649:                       PORTDbits.RD12 = 1;             //
000D5A  A882D5     BSET 0x2D5, #4
650:               
651:                       TRISDbits.TRISD7 = 0;		// Enable Motor driver pins as outputs
000D5C  A9E2D2     BCLR TRISD, #7
652:               	TRISDbits.TRISD6 = 0;		//
000D5E  A9C2D2     BCLR TRISD, #6
653:               	TRISDbits.TRISD5 = 0;		//
000D60  A9A2D2     BCLR TRISD, #5
654:               	TRISDbits.TRISD4 = 0;		//
000D62  A982D2     BCLR TRISD, #4
655:                       TRISDbits.TRISD3 = 0;		// Enable Motor driver pins as outputs
000D64  A962D2     BCLR TRISD, #3
656:               	TRISDbits.TRISD2 = 0;		//
000D66  A942D2     BCLR TRISD, #2
657:               	TRISDbits.TRISD1 = 0;		//
000D68  A922D2     BCLR TRISD, #1
658:               	TRISDbits.TRISD0 = 0;		//
000D6A  A902D2     BCLR TRISD, #0
659:               
660:                       PORTDbits.RD7 = 0;              // Enable Motor drivers
000D6C  A9E2D4     BCLR PORTD, #7
661:                       PORTDbits.RD6 = 0;              //
000D6E  A9C2D4     BCLR PORTD, #6
662:                       PORTDbits.RD5 = 0;              //
000D70  A9A2D4     BCLR PORTD, #5
663:                       PORTDbits.RD4 = 0;              //
000D72  A982D4     BCLR PORTD, #4
664:                       PORTDbits.RD3 = 0;              // Enable Motor drivers
000D74  A962D4     BCLR PORTD, #3
665:                       PORTDbits.RD2 = 0;              //
000D76  A942D4     BCLR PORTD, #2
666:                       PORTDbits.RD1 = 0;              //
000D78  A922D4     BCLR PORTD, #1
667:                       PORTDbits.RD0 = 0;              //
000D7A  A902D4     BCLR PORTD, #0
668:               	/////////////// Output Compare 8  Setup  ////////////////////////////////////////////////////////////////////
669:               	OC8CON = 0;			// Turn off Output Compare Module
000D7C  EB0200     CLR W4
000D7E  880D74     MOV W4, OC8CON
670:               	OC8RS = 0;			// Write duty cycle buffer register
000D80  EB0200     CLR W4
000D82  880D54     MOV W4, OC8RS
671:               	OC8R = 0;			// Write OCR to initial duty cycle value
000D84  EB0200     CLR W4
000D86  880D64     MOV W4, OC8R
672:               	OC8CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000D88  800D74     MOV OC8CON, W4
000D8A  A10004     BCLR W4, #0
000D8C  A01004     BSET W4, #1
000D8E  A02004     BSET W4, #2
000D90  880D74     MOV W4, OC8CON
673:               					// "111" Set OC mode to Simple PMW with Fault input
674:               	OC8CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000D92  A961AE     BCLR OC8CON, #3
675:                                                       // "1" Timer 3 as time base
676:               	/////////////// Output Compare 7  Setup  ////////////////////////////////////////////////////////////////////
677:               	OC7CON = 0;			// Turn off Output Compare Module
000D94  EB0200     CLR W4
000D96  880D44     MOV W4, OC7CON
678:               	OC7RS = 0;			// Write duty cycle buffer register
000D98  EB0200     CLR W4
000D9A  880D24     MOV W4, OC7RS
679:               	OC7R = 0xFFFF;			// Write OCR to initial duty cycle value
000D9C  EB8200     SETM W4
000D9E  880D34     MOV W4, OC7R
680:               	OC7CONbits.OCM = 0b101;		// Dual output match mode - continuous
000DA0  800D44     MOV OC7CON, W4
000DA2  A00004     BSET W4, #0
000DA4  A11004     BCLR W4, #1
000DA6  A02004     BSET W4, #2
000DA8  880D44     MOV W4, OC7CON
681:                                                           // "110" Set OC mode to Simple PMW without Fault input
682:                                                           // "111" Set OC mode to Simple PMW with Fault input
683:               	OC7CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000DAA  A961A8     BCLR OC7CON, #3
684:                                                           // "1" Timer 3 as time base
685:                       /////////////// Output Compare 6  Setup  ////////////////////////////////////////////////////////////////////
686:               	OC6CON = 0;			// Turn off Output Compare Module
000DAC  EB0200     CLR W4
000DAE  880D14     MOV W4, OC6CON
687:               	OC6RS = 0;			// Write duty cycle buffer register
000DB0  EB0200     CLR W4
000DB2  880CF4     MOV W4, OC6RS
688:               	OC6R = 0;			// Write OC2R to initial duty cycle value
000DB4  EB0200     CLR W4
000DB6  880D04     MOV W4, OC6R
689:               	OC6CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000DB8  800D14     MOV OC6CON, W4
000DBA  A10004     BCLR W4, #0
000DBC  A01004     BSET W4, #1
000DBE  A02004     BSET W4, #2
000DC0  880D14     MOV W4, OC6CON
690:                                                           // "111" Set OC mode to Simple PMW with Fault input
691:               	OC6CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000DC2  A961A2     BCLR OC6CON, #3
692:                                                           // "1" Timer 3 as time base
693:                       /////////////// Output Compare 5  Setup  ////////////////////////////////////////////////////////////////////
694:               	OC5CON = 0;			// Turn off Output Compare Module
000DC4  EB0200     CLR W4
000DC6  880CE4     MOV W4, OC5CON
695:               	OC5RS = 0;			// Write duty cycle buffer register
000DC8  EB0200     CLR W4
000DCA  880CC4     MOV W4, OC5RS
696:               	OC5R = 0xFFFF;			// Write OC2R to initial duty cycle value
000DCC  EB8200     SETM W4
000DCE  880CD4     MOV W4, OC5R
697:               	OC5CONbits.OCM = 0b101;		// Dual output match mode - continuous
000DD0  800CE4     MOV OC5CON, W4
000DD2  A00004     BSET W4, #0
000DD4  A11004     BCLR W4, #1
000DD6  A02004     BSET W4, #2
000DD8  880CE4     MOV W4, OC5CON
698:                                                           // "110" Set OC mode to Simple PMW without Fault input
699:                                                           // "111" Set OC mode to Simple PMW with Fault input
700:               	OC5CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000DDA  A9619C     BCLR OC5CON, #3
701:                                                           // "1" Timer 3 as time base
702:                       /////////////// Output Compare 4  Setup  ////////////////////////////////////////////////////////////////////
703:               	OC4CON = 0;			// Turn off Output Compare Module
000DDC  EB0200     CLR W4
000DDE  880CB4     MOV W4, OC4CON
704:               	OC4RS = 0;			// Write duty cycle buffer register
000DE0  EB0200     CLR W4
000DE2  880C94     MOV W4, OC4RS
705:               	OC4R = 0;			// Write OC2R to initial duty cycle value
000DE4  EB0200     CLR W4
000DE6  880CA4     MOV W4, OC4R
706:               	OC4CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000DE8  800CB4     MOV OC4CON, W4
000DEA  A10004     BCLR W4, #0
000DEC  A01004     BSET W4, #1
000DEE  A02004     BSET W4, #2
000DF0  880CB4     MOV W4, OC4CON
707:                                                           // "111" Set OC mode to Simple PMW with Fault input
708:               	OC4CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000DF2  A96196     BCLR OC4CON, #3
709:                                                           // "1" Timer 3 as time base
710:                       /////////////// Output Compare 3  Setup  ////////////////////////////////////////////////////////////////////
711:               	OC3CON = 0;			// Turn off Output Compare Module
000DF4  EB0200     CLR W4
000DF6  880C84     MOV W4, OC3CON
712:               	OC3RS = 0;			// Write duty cycle buffer register
000DF8  EB0200     CLR W4
000DFA  880C64     MOV W4, OC3RS
713:               	OC3R = 0;			// Write OC2R to initial duty cycle value
000DFC  EB0200     CLR W4
000DFE  880C74     MOV W4, OC3R
714:               	OC3CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000E00  800C84     MOV OC3CON, W4
000E02  A10004     BCLR W4, #0
000E04  A01004     BSET W4, #1
000E06  A02004     BSET W4, #2
000E08  880C84     MOV W4, OC3CON
715:                                                           // "111" Set OC mode to Simple PMW with Fault input
716:               	OC3CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000E0A  A96190     BCLR OC3CON, #3
717:                                                           // "1" Timer 3 as time base
718:                       /////////////// Output Compare 2  Setup  ////////////////////////////////////////////////////////////////////
719:               	OC2CON = 0;			// Turn off Output Compare Module
000E0C  EB0200     CLR W4
000E0E  880C54     MOV W4, OC2CON
720:               	OC2RS = 0;			// Write duty cycle buffer register
000E10  EB0200     CLR W4
000E12  880C34     MOV W4, OC2RS
721:               	OC2R = 0;			// Write OC2R to initial duty cycle value
000E14  EB0200     CLR W4
000E16  880C44     MOV W4, OC2R
722:               	OC2CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000E18  800C54     MOV OC2CON, W4
000E1A  A10004     BCLR W4, #0
000E1C  A01004     BSET W4, #1
000E1E  A02004     BSET W4, #2
000E20  880C54     MOV W4, OC2CON
723:                                                           // "111" Set OC mode to Simple PMW with Fault input
724:               	OC2CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000E22  A9618A     BCLR OC2CON, #3
725:                                                           // "1" Timer 3 as time base
726:                       /////////////// Output Compare 1  Setup  ////////////////////////////////////////////////////////////////////
727:               	OC1CON = 0;			// Turn off Output Compare Module
000E24  EB0200     CLR W4
000E26  880C24     MOV W4, OC1CON
728:               	OC1RS = 1;			// Write duty cycle buffer register
000E28  200014     MOV #0x1, W4
000E2A  880C04     MOV W4, OC1RS
729:               	OC1R = 0;			// Write OC2R to initial duty cycle value
000E2C  EB0200     CLR W4
000E2E  880C14     MOV W4, OC1R
730:               	OC1CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000E30  800C24     MOV OC1CON, W4
000E32  A10004     BCLR W4, #0
000E34  A01004     BSET W4, #1
000E36  A02004     BSET W4, #2
000E38  880C24     MOV W4, OC1CON
731:                                                           // "111" Set OC mode to Simple PMW with Fault input
732:               	OC1CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000E3A  A96184     BCLR OC1CON, #3
733:                                                           // "1" Timer 3 as time base
734:               	//////////// Timer 2  Setup  ////////////////////////////////////////////////////////////////////////////////
735:               	T2CON = 0;			// Stops the Timer2 and reset control register
000E3C  EB0200     CLR W4
000E3E  880884     MOV W4, T2CON
736:               	TMR2 = 0;			// Clear contents of the timer register
000E40  EB0200     CLR W4
000E42  880834     MOV W4, TMR2
737:               	T2CONbits.TCKPS = T2_TCKPS;	// Timer Input Clock Prescale Select bits
000E44  800884     MOV T2CON, W4
000E46  A14004     BCLR W4, #4
000E48  A15004     BCLR W4, #5
000E4A  880884     MOV W4, T2CON
738:                                                           // 11 = 1:256 prescale value
739:                                                           // 10 = 1:64 prescale value
740:                                                           // 01 = 1:8 prescale value
741:                                                           // 00 = 1:1 prescale value
742:               	PR2 = T2_PR2;			// Load the Period register
000E4C  205C24     MOV #0x5C2, W4
000E4E  880864     MOV W4, PR2
743:               	IPC1bits.T2IP = 0x3;		// Set Timer2 interrupt priority to 3 (1-lowest, 7-highiest)
000E50  8004B4     MOV IPC1, W4
000E52  A08004     BSET W4, #8
000E54  A09004     BSET W4, #9
000E56  A1A004     BCLR W4, #10
000E58  8804B4     MOV W4, IPC1
744:               	IFS0bits.T2IF = 0;		// Clear the Timer2 interrupt status flag
000E5A  A9C084     BCLR IFS0, #6
745:               	IEC0bits.T2IE = 1;		// Enable Timer2 interrupts
000E5C  A8C08C     BSET IEC0, #6
746:               	T2CONbits.TON = 1;		// Start Timer2
000E5E  A8E111     BSET 0x111, #7
747:               
748:                       //motor->StepInc = MCurve[motor->SpeedAbs][1];
749:                       //motor->PrescVal = MCurve[motor->SpeedAbs][2];
750:               }
000E60  FA8000     ULNK
000E62  060000     RETURN
751:               
752:               ///////// Timer2 Interrupt routine //////////////////////
753:               void __attribute__((__interrupt__,no_auto_psv)) _T2Interrupt(void)
754:               {
000E64  F80036     PUSH RCOUNT
000E66  BE9F80     MOV.D W0, [W15++]
000E68  BE9F82     MOV.D W2, [W15++]
000E6A  BE9F84     MOV.D W4, [W15++]
000E6C  BE9F86     MOV.D W6, [W15++]
000E6E  FA0000     LNK #0x0
755:               	IFS0bits.T2IF = 0;				// Clear Timer2 interrupt status flag
000E70  A9C084     BCLR IFS0, #6
756:                       ADCon1_m = ADCON1;
000E72  801504     MOV ADCON1, W4
000E74  884A74     MOV W4, ADCon1_m
757:                       MotorDecayLoad();                               // Load decay timers for motor drivers
000E76  07FC68     RCALL MotorDecayLoad
758:                       //MotorRightDecayLoad();
759:                       //MotorRightDecayLoad();
760:                       ADCUpdate();                                    // Update anologue values
000E78  07009A     RCALL ADCUpdate
761:                       //MotorRightDriver();
762:                       //MotorRightDriver();
763:                       MotorsInputUpdate();
000E7A  07FF5E     RCALL MotorsInputUpdate
764:                       
765:                       //Ticks();
766:                       asm ("inc %0" : "+g"(Tick));
000E7C  EC2948     INC Tick
767:               
768:                       if(debug == 1)
000E7E  804A64     MOV debug, W4
000E80  520FE1     SUB W4, #0x1, [W15]
000E82  3A0002     BRA NZ, 0xE88
769:                       {
770:                           temp = 0;
000E84  EB0200     CLR W4
000E86  884A84     MOV W4, temp
771:               
772:                       }
773:                       if(debug == 2)
000E88  804A64     MOV debug, W4
000E8A  520FE2     SUB W4, #0x2, [W15]
000E8C  3A0002     BRA NZ, 0xE92
774:                       {
775:                           temp = 0;
000E8E  EB0200     CLR W4
000E90  884A84     MOV W4, temp
776:               
777:                       }
778:                       if(debug == 3)
000E92  804A64     MOV debug, W4
000E94  520FE3     SUB W4, #0x3, [W15]
000E96  3A0002     BRA NZ, 0xE9C
779:                       {
780:                           temp = 0;
000E98  EB0200     CLR W4
000E9A  884A84     MOV W4, temp
781:               
782:                       }
783:                       if(debug == 4)
000E9C  804A64     MOV debug, W4
000E9E  520FE4     SUB W4, #0x4, [W15]
000EA0  3A0002     BRA NZ, 0xEA6
784:                       {
785:                           temp = 0;
000EA2  EB0200     CLR W4
000EA4  884A84     MOV W4, temp
786:               
787:                       }
788:                       if(debug == 5)
000EA6  804A64     MOV debug, W4
000EA8  520FE5     SUB W4, #0x5, [W15]
000EAA  3A0002     BRA NZ, 0xEB0
789:                       {
790:                           temp = 0;
000EAC  EB0200     CLR W4
000EAE  884A84     MOV W4, temp
791:                           
792:                       }
793:                       if(debug == 6)
000EB0  804A64     MOV debug, W4
000EB2  520FE6     SUB W4, #0x6, [W15]
000EB4  3A0002     BRA NZ, 0xEBA
794:                       {
795:                           debug = 0;
000EB6  EB0200     CLR W4
000EB8  884A64     MOV W4, debug
796:               
797:                       }
798:                       debug++;
000EBA  804A64     MOV debug, W4
000EBC  E80204     INC W4, W4
000EBE  884A64     MOV W4, debug
799:               
800:                       
801:               //        Present++;
802:               //        if(Present == 800)
803:               //        {
804:               //            Present = 0;
805:               //            if(Speed == 250)
806:               //                SpeedChange = -1;
807:               //            if(Speed == -250)
808:               //                SpeedChange = 1;
809:               //            Speed += SpeedChange;
810:               //        }
811:               //        Tick = 1;
812:               
813:               }
000EC0  FA8000     ULNK
000EC2  BE034F     MOV.D [--W15], W6
000EC4  BE024F     MOV.D [--W15], W4
000EC6  BE014F     MOV.D [--W15], W2
000EC8  BE004F     MOV.D [--W15], W0
000ECA  F90036     POP RCOUNT
000ECC  064000     RETFIE
814:               
815:               //void MotorAcc(int dir,int rate, int inc )
816:               //{
817:               //    Direction = dir;
818:               //    while(1)
819:               //    {
820:               //        while(Tick == 0);
821:               //        Tick = 0;
822:               //        Rev = Rev + inc;
823:               //        if(Rev > rate)
824:               //        {
825:               //          Rev = rate;
826:               //          break;
827:               //        }
828:               //        if(Rev < 0)
829:               //        {
830:               //           Rev = 0;
831:               //          break;
832:               //        }
833:               //    }
834:               //
835:               //}
---  C:/MCprojects/Segway/Segway/ADC.c  -----------------------------------------------------------------
1:                 /**********************************************************************c
2:                  * Author: Marcin Dec
3:                  * Date: 11.08.2015
4:                  * FileName:        ADC.c
5:                  * Dependencies:    ADC.h
6:                  * Processor:       dsPIC30F6013A
7:                  * Compiler:        MPLAB® XC16 C Compiler
8:                  *
9:                  ************************************************************************/
10:                #include <p30f6013A.h>
11:                /////////////// Motor Right ///////////////////
12:                //  CSA - AN8/RB8
13:                //  CSB - AN9/RB9
14:                /////////////// Motor Left ///////////////////
15:                //  CSA - AN6/OCFA/RB6
16:                //  CSB - AN7/RB7
17:                /////////////// Battery //////////////////////
18:                // Current - AN10/RB10
19:                // Voltage - AN11/RB11
20:                
21:                #define ADC_BUFF_LENGTH 5
22:                #define ADC_INPUTS  6
23:                int* ADC16Ptr;
24:                int ADCBuff[ADC_BUFF_LENGTH];
25:                const int ADCInputs[ADC_INPUTS] = {8, 9, 6, 7, 10, 11};
26:                int ADCCSARight;
27:                int ADCCSBRight;
28:                int ADCCSALeft;
29:                int ADCCSBLeft;
30:                int ADCCurrent;
31:                int ADCVoltage;
32:                int ADCCSARightArr[ADC_BUFF_LENGTH];
33:                int ADCCSBRightArr[ADC_BUFF_LENGTH];
34:                int ADCCSALeftArr[ADC_BUFF_LENGTH];
35:                int ADCCSBLeftArr[ADC_BUFF_LENGTH];
36:                int ADCCurrentArr[ADC_BUFF_LENGTH];
37:                int ADCVoltageArr[ADC_BUFF_LENGTH];
38:                int ADCon1;
39:                int ADCon1_2;
40:                void ADCBuffLoad(int* buff) {
000ECE  FA0004     LNK #0x4
000ED0  980710     MOV W0, [W14+2]
41:                    int i;
42:                    for (i = 0; i < 6; i++) {
000ED2  EB0200     CLR W4
000ED4  780F04     MOV W4, [W14]
000ED6  37000B     BRA 0xEEE
000EEC  E80F1E     INC [W14], [W14]
000EEE  78021E     MOV [W14], W4
000EF0  520FE5     SUB W4, #0x5, [W15]
000EF2  34FFF2     BRA LE, 0xED8
43:                        *(buff + i) = *(ADC16Ptr + i);
000ED8  78021E     MOV [W14], W4
000EDA  420204     ADD W4, W4, W4
000EDC  90029E     MOV [W14+2], W5
000EDE  428284     ADD W5, W4, W5
000EE0  804486     MOV ADC16Ptr, W6
000EE2  78021E     MOV [W14], W4
000EE4  420204     ADD W4, W4, W4
000EE6  430204     ADD W6, W4, W4
000EE8  780214     MOV [W4], W4
000EEA  780A84     MOV W4, [W5]
44:                    }
45:                }
000EF4  FA8000     ULNK
000EF6  060000     RETURN
46:                void ADCBuffCopy(int* buff, int* copy) {
000EF8  FA0006     LNK #0x6
000EFA  980710     MOV W0, [W14+2]
000EFC  980721     MOV W1, [W14+4]
47:                    int i;
48:                    for (i = 0; i < 6; i++) {
000EFE  EB0200     CLR W4
000F00  780F04     MOV W4, [W14]
000F02  37000B     BRA 0xF1A
000F18  E80F1E     INC [W14], [W14]
000F1A  78021E     MOV [W14], W4
000F1C  520FE5     SUB W4, #0x5, [W15]
000F1E  34FFF2     BRA LE, 0xF04
49:                        *(copy + i) = *(buff + i);
000F04  78021E     MOV [W14], W4
000F06  420204     ADD W4, W4, W4
000F08  9002AE     MOV [W14+4], W5
000F0A  428284     ADD W5, W4, W5
000F0C  78021E     MOV [W14], W4
000F0E  420204     ADD W4, W4, W4
000F10  90031E     MOV [W14+2], W6
000F12  430204     ADD W6, W4, W4
000F14  780214     MOV [W4], W4
000F16  780A84     MOV W4, [W5]
50:                    }
51:                }
000F20  FA8000     ULNK
000F22  060000     RETURN
52:                int ADCMax(int* buff) {
000F24  FA0006     LNK #0x6
000F26  980720     MOV W0, [W14+4]
53:                    int max = 0, i;
000F28  EB0200     CLR W4
000F2A  780F04     MOV W4, [W14]
54:                    for (i = 0; i < ADC_BUFF_LENGTH; i++) {
000F2C  EB0200     CLR W4
000F2E  980714     MOV W4, [W14+2]
000F30  370010     BRA 0xF52
000F4C  90021E     MOV [W14+2], W4
000F4E  E80204     INC W4, W4
000F50  980714     MOV W4, [W14+2]
000F52  90021E     MOV [W14+2], W4
000F54  520FE4     SUB W4, #0x4, [W15]
000F56  34FFED     BRA LE, 0xF32
55:                        if (*buff > max) {
000F32  90022E     MOV [W14+4], W4
000F34  780214     MOV [W4], W4
000F36  520F9E     SUB W4, [W14], [W15]
000F38  340006     BRA LE, 0xF46
56:                            max = *buff++;
000F3A  90022E     MOV [W14+4], W4
000F3C  780F14     MOV [W4], [W14]
000F3E  90022E     MOV [W14+4], W4
000F40  E88204     INC2 W4, W4
000F42  980724     MOV W4, [W14+4]
000F44  370003     BRA 0xF4C
57:                        } else buff++;
000F46  90022E     MOV [W14+4], W4
000F48  E88204     INC2 W4, W4
000F4A  980724     MOV W4, [W14+4]
58:                    }
59:                    return max;
000F58  78021E     MOV [W14], W4
60:                }
000F5A  780004     MOV W4, W0
000F5C  FA8000     ULNK
000F5E  060000     RETURN
61:                
62:                int ADCMean(int* buff) {
000F60  FA0006     LNK #0x6
000F62  980720     MOV W0, [W14+4]
63:                    int mean = 0, i;
000F64  EB0200     CLR W4
000F66  780F04     MOV W4, [W14]
64:                    for (i = 0; i < ADC_BUFF_LENGTH; i++) {
000F68  EB0200     CLR W4
000F6A  980714     MOV W4, [W14+2]
000F6C  370009     BRA 0xF80
000F7A  90021E     MOV [W14+2], W4
000F7C  E80204     INC W4, W4
000F7E  980714     MOV W4, [W14+2]
000F80  90021E     MOV [W14+2], W4
000F82  520FE4     SUB W4, #0x4, [W15]
000F84  34FFF4     BRA LE, 0xF6E
65:                        mean += *buff++;
000F6E  90022E     MOV [W14+4], W4
000F70  780214     MOV [W4], W4
000F72  420F1E     ADD W4, [W14], [W14]
000F74  90022E     MOV [W14+4], W4
000F76  E88204     INC2 W4, W4
000F78  980724     MOV W4, [W14+4]
66:                    }
67:                    mean >>= 2;
000F86  78021E     MOV [W14], W4
000F88  DEA242     ASR W4, #2, W4
000F8A  780F04     MOV W4, [W14]
68:                    return mean;
000F8C  78021E     MOV [W14], W4
69:                }
000F8E  780004     MOV W4, W0
000F90  FA8000     ULNK
000F92  060000     RETURN
70:                
71:                int ADCInpChange(void) {
000F94  FA0000     LNK #0x0
72:                    static int index = -1;
73:                    index++;
000F96  804AA4     MOV 0x954, W4
000F98  E80204     INC W4, W4
000F9A  884AA4     MOV W4, 0x954
74:                    if (index >= ADC_INPUTS)
000F9C  804AA4     MOV 0x954, W4
000F9E  520FE5     SUB W4, #0x5, [W15]
000FA0  340002     BRA LE, 0xFA6
75:                        index = 0;
000FA2  EB0200     CLR W4
000FA4  884AA4     MOV W4, 0x954
76:                    //ADCHS = (ADCHS & 0xFFF0) | ADCInputs[index];
77:                    return index;
000FA6  804AA4     MOV 0x954, W4
78:                }
000FA8  780004     MOV W4, W0
000FAA  FA8000     ULNK
000FAC  060000     RETURN
79:                
80:                void ADCUpdate(void) {
000FAE  FA0002     LNK #0x2
81:                    static int index = -1;
82:                    int index_new;
83:                    ADCon1_2 = ADCON1;
000FB0  801504     MOV ADCON1, W4
000FB2  884734     MOV W4, ADCon1_2
84:                    ADCON1bits.ASAM = 0; // stop auto sampling
000FB4  A942A0     BCLR ADCON1, #2
85:                    ADCon1 = ADCON1;
000FB6  801504     MOV ADCON1, W4
000FB8  884724     MOV W4, ADCon1
86:                    //ADCON1bits.SAMP = 0; // stop sampling if in progress
87:                    ADCBuffLoad(ADCBuff); // retain ADCBUF content
000FBA  208920     MOV #0x892, W0
000FBC  07FF88     RCALL ADCBuffLoad
88:                    index_new = ADCInpChange(); // switch channel and return its index
000FBE  07FFEA     RCALL ADCInpChange
000FC0  780200     MOV W0, W4
000FC2  780F04     MOV W4, [W14]
89:                    //IFS0bits.ADIF = 0;
90:                    ADCON1bits.ASAM = 1; // start next sampling cycle
000FC4  A842A0     BSET ADCON1, #2
91:                    switch (index) {
000FC6  804A94     MOV 0x952, W4
000FC8  DEA2CF     ASR W4, #15, W5
000FCA  200056     MOV #0x5, W6
000FCC  200007     MOV #0x0, W7
000FCE  520F86     SUB W4, W6, [W15]
000FD0  5A8F87     SUBB W5, W7, [W15]
000FD2  3E001F     BRA GTU, 0x1012
000FD4  016004     BRA W4
000FD6  370005     BRA 0xFE2
000FD8  370008     BRA 0xFEA
000FDA  37000B     BRA 0xFF2
000FDC  37000E     BRA 0xFFA
000FDE  370011     BRA 0x1002
000FE0  370014     BRA 0x100A
92:                        case 0:
93:                            ADCBuffCopy(ADCBuff, ADCCSARightArr);
000FE2  208A81     MOV #0x8A8, W1
000FE4  208920     MOV #0x892, W0
000FE6  07FF88     RCALL ADCBuffCopy
94:                            //ADCCSARight = ADCMax(ADCBuff);
95:                            break;
000FE8  370014     BRA 0x1012
96:                        case 1:
97:                            ADCBuffCopy(ADCBuff, ADCCSBRightArr);
000FEA  208B21     MOV #0x8B2, W1
000FEC  208920     MOV #0x892, W0
000FEE  07FF84     RCALL ADCBuffCopy
98:                            //ADCCSBRight = ADCMax(ADCBuff);
99:                            break;
000FF0  370010     BRA 0x1012
100:                       case 2:
101:                           ADCBuffCopy(ADCBuff, ADCCSALeftArr);
000FF2  208BC1     MOV #0x8BC, W1
000FF4  208920     MOV #0x892, W0
000FF6  07FF80     RCALL ADCBuffCopy
102:                           //ADCCSALeft = ADCMax(ADCBuff);
103:                           break;
000FF8  37000C     BRA 0x1012
104:                       case 3:
105:                           ADCBuffCopy(ADCBuff, ADCCSBLeftArr);
000FFA  208C61     MOV #0x8C6, W1
000FFC  208920     MOV #0x892, W0
000FFE  07FF7C     RCALL ADCBuffCopy
106:                           //ADCCSBLeft = ADCMax(ADCBuff);
107:                           break;
001000  370008     BRA 0x1012
108:                       case 4:
109:                           ADCBuffCopy(ADCBuff, ADCCurrentArr);
001002  208D01     MOV #0x8D0, W1
001004  208920     MOV #0x892, W0
001006  07FF78     RCALL ADCBuffCopy
110:                           //ADCCurrent = ADCMean(ADCBuff);
111:                           break;
001008  370004     BRA 0x1012
112:                       case 5:
113:                           ADCBuffCopy(ADCBuff, ADCVoltageArr);
00100A  208DA1     MOV #0x8DA, W1
00100C  208920     MOV #0x892, W0
00100E  07FF74     RCALL ADCBuffCopy
114:                           //ADCVoltage = ADCMean(ADCBuff);
115:                           break;
001010  000000     NOP
116:                   }
117:                   index = index_new; // retain index for next cycle
001012  78021E     MOV [W14], W4
001014  884A94     MOV W4, 0x952
118:               }
001016  FA8000     ULNK
001018  060000     RETURN
119:               
120:               void ADCInit(void) {
00101A  FA0000     LNK #0x0
121:                   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
122:                   /* bit 15-0 PCFG<15:0>: Analog Input Pin Configuration Control bits
123:                   1 = Analog input pin in Digital mode, port read input enabled, A/D input multiplexer input connected to AVSS
124:                   0 = Analog input pin in Analog mode, port read input disabled, A/D samples pin voltage */
125:                   ADPCFG = 0x0000; // all PORTB pins configured as analog
00101C  EB0200     CLR W4
00101E  881544     MOV W4, ADPCFG
126:                   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
127:                   /* bit 15 ADON: A/D Operating Mode bit
128:                   0,0,0,0|00,00,|111,0,|0,0,0,0
129:                   1 = A/D converter module is operating
130:                   *0 = A/D converter is off
131:                   bit 14 Unimplemented: Read as ?0?
132:                   bit 13 ADSIDL: Stop in Idle Mode bit
133:                   1 = Discontinue module operation when device enters Idle mode
134:                   *0 = Continue module operation in Idle mode
135:                   bit 12-10 Unimplemented: Read as ?0?
136:                   bit 9-8 FORM<1:0>: Data Output Format bits
137:                   11 = Signed fractional (DOUT = sddd dddd dddd 0000)
138:                   10 = Fractional (DOUT = dddd dddd dddd 0000)
139:                   01 = Signed integer (DOUT = ssss sddd dddd dddd)
140:                   *00 = Integer (DOUT = 0000 dddd dddd dddd)
141:                   bit 7-5 SSRC<2:0>: Conversion Trigger Source Select bits
142:                   *111 = Internal counter ends sampling and starts conversion (auto convert)
143:                   110 = Reserved
144:                   101 = Reserved
145:                   100 = Reserved
146:                   011 = Motor Control PWM interval ends sampling and starts conversion
147:                   010 = General purpose Timer3 compare ends sampling and starts conversion
148:                   001 = Active transition on INT0 pin ends sampling and starts conversion
149:                   000 = Clearing SAMP bit ends sampling and starts conversion
150:                   bit 4-3 Unimplemented: Read as ?0?
151:                   bit 2 ASAM: A/D Sample Auto-Start bit
152:                   1 = Sampling begins immediately after last conversion completes. SAMP bit is auto set.
153:                   *0 = Sampling begins when SAMP bit set
154:                   bit 1 SAMP: A/D Sample Enable bit
155:                   1 = At least one A/D sample/hold amplifier is sampling
156:                   *0 = A/D sample/hold amplifiers are holding
157:                   When ASAM = 0, writing ?1? to this bit will start sampling.
158:                   When SSRC = 000, writing ?0? to this bit will end sampling and start conversion.
159:                   bit 0 DONE: A/D Conversion Status bit
160:                   1 = A/D conversion is done
161:                   *0 = A/D conversion is not done
162:                   Clearing this bit will not effect any operation in progress.
163:                   Cleared by software or start of a new conversion. */
164:                   ADCON1 = 0x00E0; // SSRC bit = 111 implies internal
001020  200E04     MOV #0xE0, W4
001022  881504     MOV W4, ADCON1
165:                   // counter ends sampling and starts converting.
166:                   // Sampling begins when SAMP bit set
167:                   // Integer (DOUT = 0000 dddd dddd dddd)
168:                   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
169:                   /* bit 15-13 Unimplemented: Read as ?0?
170:                   bit 12 CH0NB: Channel 0 Negative Input Select for MUX B Multiplexer Setting bit
171:                   Same definition as bit <4> (see Note).
172:                   bit 11-8 CH0SB<3:0>: Channel 0 Positive Input Select for MUX B Multiplexer Setting bit
173:                   Same definition as bits <3:0> (see Note).
174:                   bit 7-5 Unimplemented: Read as ?0?
175:                   bit 4 CH0NA: Channel 0 Negative Input Select for MUX A Multiplexer Setting bit
176:                   1 = Channel 0 negative input is AN1
177:                   0 = Channel 0 negative input is VREFbit
178:                   3-0 CH0SA<3:0>: Channel 0 Positive Input Select for MUX A Multiplexer Setting bit
179:                   1111 = Channel 0 positive input is AN15
180:                   1110 = Channel 0 positive input is AN14
181:                   1101 = Channel 0 positive input is AN13
182:                   ·····
183:                   0001 = Channel 0 positive input is AN1
184:                   0000 = Channel 0 positive input is AN0 */
185:                   ADCHS = 0x0008; // Connect AN8/RB8 as CH0 input in first convertion cycle
001024  200084     MOV #0x8, W4
001026  881534     MOV W4, ADCHS
186:                   ////////////////////////////////////////////////////////////////////////////////////////////////////
187:                   ADCSSL = 0;
001028  EB0200     CLR W4
00102A  881554     MOV W4, ADCSSL
188:                   /////////////////////////////////////////////////////////////////////////////////////////////
189:                   /* bit 15-13 Unimplemented: Read as ?0?
190:                   000,0|00010,|0,0,10|0110
191:                   bit 12-8 SAMC<4:0>: Auto Sample Time bits
192:                   11111 = 31 TAD
193:                   ·····
194:                   *00010 = 2 TAD
195:                   *00001 = 1 TAD
196:                   00000 = 0 TAD
197:                   bit 7 ADRC: A/D Conversion Clock Source bit
198:                   1 = A/D internal RC clock
199:                   *0 = Clock derived from system clock
200:                   bit 6 Unimplemented: Read as ?0?
201:                   bit 5-0 ADCS<5:0>: A/D Conversion Clock Select bits
202:                   111111 = TCY/2 ? (ADCS<5:0> + 1) = 32 ? TCY
203:                   ······
204:                   000001 = TCY/2 ? (ADCS<5:0> + 1) = TCY
205:                   000000 = TCY/2 ? (ADCS<5:0> + 1) = TCY/2 */
206:                   ADCON3 = 0x0226; // Sample time = 2Tad, Tad = 666.67 ns, ADCS = 2TAD/TCY - 1 = 2*666.67/33.9 - 1 = 38 = 100110
00102C  202264     MOV #0x226, W4
00102E  881524     MOV W4, ADCON3
207:                   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
208:                   /* bit 15-13 VCFG<2:0>: Voltage Reference Configuration bits
209:                   000,0,|0,0,00,|0,0,01|00,0,0
210:                    VCFG   |A/D VREFH          |A/D VREFL
211:                   ---------------------------------------------
212:                   000     |   AVDD            |   AVSS
213:                   001     |External VREF+ pin |AVSS
214:                   010     |AVDD               |External VREF- pin
215:                   011     |External VREF+ pin |External VREF- pin
216:                   1xx     |AVDD               |AVSS
217:                   ---------------------------------------------
218:                   bit 12 Reserved: User should write ?0? to this location
219:                   bit 11 Unimplemented: Read as ?0?
220:                   bit 10 CSCNA: Scan Input Selections for CH0+ S/H Input for MUX A Input Multiplexer Setting bit
221:                   1 = Scan inputs
222:                   0 = Do not scan inputs
223:                   bit 9-8 Unimplemented: Read as ?0?
224:                   bit 7 BUFS: Buffer Fill Status bit
225:                   Only valid when BUFM = 1 (ADRES split into 2 x 8-word buffers)
226:                   1 = A/D is currently filling buffer 0x8-0xF, user should access data in 0x0-0x7
227:                   0 = A/D is currently filling buffer 0x0-0x7, user should access data in 0x8-0xF
228:                   bit 6 Unimplemented: Read as ?0?
229:                   bit 5-2 SMPI<3:0>: Sample/Convert Sequences Per Interrupt Selection bits
230:                   1111 = Interrupts at the completion of conversion for each 16th sample/convert sequence
231:                   1110 = Interrupts at the completion of conversion for each 15th sample/convert sequence
232:                   .....
233:                   0001 = Interrupts at the completion of conversion for each 2nd sample/convert sequence
234:                   0000 = Interrupts at the completion of conversion for each sample/convert sequence
235:                   bit 1 BUFM: Buffer Mode Select bit
236:                   1 = Buffer configured as two 8-word buffers ADCBUF(15...8), ADCBUF(7...0)
237:                   0* = Buffer configured as one 16-word buffer ADCBUF(15...0)
238:                   bit 0 ALTS: Alternate Input Sample Mode Select bit
239:                   1 = Uses MUX A input multiplexer settings for first sample, then alternate between MUX B and MUX A input
240:                   multiplexer settings for all subsequent samples
241:                   0* = Always use MUX A input multiplexer settings */
242:                   ADCON2 = 0x0010; // Interrupt wil not be used anyway
001030  200104     MOV #0x10, W4
001032  881514     MOV W4, ADCON2
243:                   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
244:                   ADCON1bits.ADON = 1; // turn ADC ON
001034  A8E2A1     BSET 0x2A1, #7
245:               
246:                   ADC16Ptr = &ADCBUF0; // initialize ADCBUF pointer
001036  202804     MOV #0x280, W4
001038  884484     MOV W4, ADC16Ptr
247:                   IFS0bits.ADIF = 0; // clear ADC interrupt flag
00103A  A96085     BCLR 0x85, #3
248:                   //ADCON1bits.ASAM = 1; // auto start sampling
249:                   // for 1Tad then go to conversion
250:                   //while (!IFS0bits.ADIF); // conversion done?
251:                   //ADCON1bits.ASAM = 0; // yes then stop sample/convert
252:                   ///for (count = 0; count < 16; count++) // average the 16 ADC value
253:                   //ADCValue = ADCValue + *ADC16Ptr++;
254:                   //ADCValue = ADCValue >> 4;
255:                   //} // repeat
256:               }
00103C  FA8000     ULNK
00103E  060000     RETURN

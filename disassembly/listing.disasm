Disassembly Listing for Segway 19.07.15
Generated From:
C:/Marcin Dec/private/Segway/Segway 19.07.15.X/dist/default/debug/Segway_19.07.15.X.debug.elf
2015-10-15 15:41:44

---  C:/Marcin Dec/private/Segway/Segway 19.07.15.X/main.c  ---------------------------------------------
1:                 /**********************************************************************c
2:                 * Author: Marcin Dec
3:                 * Date: 31.01.2015
4:                 * FileName:        main.c
5:                 * Dependencies:    Header (.h) files if applicable, see below
6:                 * Processor:       dsPIC30F6013A
7:                 * Compiler:        MPLAB® C30 v3.00 or higher
8:                 *
9:                 ************************************************************************/
10:                
11:                #include <p30f6013A.h>
12:                #include "ADC.h"
13:                //#include "Bluetooth.h"
14:                #include "Motors.h"
15:                #include "Globals.h"
16:                #include <math.h>
17:                
18:                // T2_PERIOD is PWM period in microseconds
19:                //#define T2_PERIOD 50L
20:                //#define T2_POST 1L
21:                //#define T2_PR2 (T2_PERIOD)*(F_CY/T2_POST)/1000000L
22:                //#define MICSTEPS 64
23:                //#define PI 3.1415926535897932384626433832795F
24:                //extern union MPU5060 Mpu5060;
25:                //extern union PID Pid;
26:                extern int Tick_100;
27:                int Tick_100_;
28:                //extern int BroadcastAppend(unsigned char* frame);
29:                
30:                _FOSC(CSW_FSCM_OFF & XT_PLL16);                      // no clock switching , primary clock XT with PLL x 16
31:                _FBORPOR( MCLR_EN); //  MCLR as reset pin
32:                _FWDT(WDT_OFF);                               // watchdog disabled
33:                
34:                
35:                
36:                /* Allocate memory for buffers and drivers	*/
37:                
38:                
39:                
40:                long k;
41:                long h = 100000;
42:                int dir = 1;
43:                int rev = 32000;
44:                int incr = 200;
45:                
46:                
47:                
48:                
49:                
50:                int main(void)
51:                {
0012FC  FA0000     LNK #0x0
52:                	/* Configure Oscillator to operate the device at 40MHz.
53:                	 * Fosc= Fin*M/(N1*N2), Fcy=Fosc/4
54:                	 * Fosc= 7.37M*40/(2*2)=80Mhz for 7.37M input clock */
55:                //OSCCONbits.POST
56:                //POST<1:0>: Oscillator Postscaler Selection bits
57:                //11 = Oscillator postscaler divides clock by 64
58:                //10 = Oscillator postscaler divides clock by 16
59:                //01 = Oscillator postscaler divides clock by 4
60:                //00 = Oscillator postscaler does not alter clock
61:                //	SegwayInit();
62:                //	BroadcastAppend(Mpu5060.MPU5060Frame);
63:                //	BroadcastAppend(Pid.PidFrame);
64:                //	BroadcastAppend(Kalman.KalmanFrame);
65:                //	BroadcastAppend(Motors.MotorsFrame);
66:                //
67:                //	BluetoothInit();
68:                        ADCInit();
0012FE  07FF59     RCALL ADCInit
69:                	MotorsInit();
001300  07FE0B     RCALL MotorsInit
001302  370001     BRA 0x1306
70:                        
71:                	//unsigned int MicStepArray[MICSTEPS];
72:                //	float a = sin(3.1415926535897932384626433832795/2);
73:                //	a=a+a;
74:                
75:                //	int i;
76:                //	union
77:                //	{
78:                //		struct
79:                //		{
80:                //			unsigned int EnA;
81:                //			unsigned int EnB;
82:                //		} MicStepStruct;
83:                //		unsigned long int MicStep;
84:                //	} MicStepUnion;
85:                //	#define INP MicStepUnion.MicStepStruct
86:                //	#define MST MicStepUnion
87:                //	for(i = 0; i < MICSTEPS; i++)
88:                //	{
89:                //		float a, b;
90:                //		a = sin((float)i/(float)(MICSTEPS) * (PI/2));
91:                //		b = ((float)T2_PR2 * sin((float)i/(float)(MICSTEPS) * (PI/2)));
92:                //		INP.EnA = (unsigned int)((float)T2_PR2 * sin((float)i/(float)(MICSTEPS) * (PI/2)));
93:                //		INP.EnB = (unsigned int)((float)T2_PR2 * cos((float)i/(float)(MICSTEPS) * (PI/2)));
94:                //		MicStepArray[i] = MST.MicStep;
95:                //	}
96:                
97:                	while(1)
98:                	{
99:                        if(Tick_100 && !Tick_100_)
001306  804AB0     MOV _Tick_100, W0
001308  E00000     CP0 W0
00130A  320007     BRA Z, 0x131A
00130C  804A20     MOV Tick_100_, W0
00130E  E00000     CP0 W0
001310  3A0004     BRA NZ, 0x131A
100:                       {
101:                           Tick_100_++;
001312  804A20     MOV Tick_100_, W0
001314  E80000     INC W0, W0
001316  884A20     MOV W0, Tick_100_
001318  370009     BRA 0x132C
102:                       }
103:                       else if(Tick_100 && Tick_100_)
00131A  804AB0     MOV _Tick_100, W0
00131C  E00000     CP0 W0
00131E  320006     BRA Z, 0x132C
001320  804A20     MOV Tick_100_, W0
001322  E00000     CP0 W0
001324  320003     BRA Z, 0x132C
104:                       {
105:                           Tick_100_--;
001326  804A20     MOV Tick_100_, W0
001328  E90000     DEC W0, W0
00132A  884A20     MOV W0, Tick_100_
106:                       }
107:                       if(IFS0bits.ADIF == 1)
00132C  800421     MOV IFS0, W1
00132E  208000     MOV #0x800, W0
001330  608000     AND W1, W0, W0
001332  E00000     CP0 W0
001334  32FFE7     BRA Z, 0x1304
108:                           IFS0bits.ADIF = 0;
001336  A96085     BCLR 0x85, #3
109:               	}
001304  000000     NOP
001338  37FFE6     BRA 0x1306
110:               
111:               }
112:               
113:               
114:               
115:               
---  C:/Marcin Dec/private/Segway/Segway 19.07.15.X/Tick.s  ---------------------------------------------
                                                  1:            .section TicksSec,bss
                                                  2:            .global _Tick
                                                  3:            .global _Tick_100, _Tick_200, _Tick_400, _Tick_800
                                                  4:            .global _Tick_1600, _Tick_3200, _Tick_6400, _Tick_12800
                                                  5:            .global _Tick_25600, _Tick_51200, _Tick_102400, _Tick_204800
                                                  6:            .global _Tick_409600, _Tick_819200, _Tick_1638400, _Tick_3276800
                                                  7:      _Tick: .space 2    
                                                  8:      _Tick_100: .space 1
                                                  9:      _Tick_200: .space 1
                                                  10:     _Tick_400: .space 1
                                                  11:     _Tick_800: .space 1
                                                  12:     _Tick_1600: .space 1
                                                  13:     _Tick_3200: .space 1
                                                  14:     _Tick_6400: .space 1
                                                  15:     _Tick_12800: .space 1
                                                  16:     _Tick_25600: .space 1
                                                  17:     _Tick_51200: .space 1
                                                  18:     _Tick_102400: .space 1
                                                  19:     _Tick_204800: .space 1
                                                  20:     _Tick_409600: .space 1
                                                  21:     _Tick_819200: .space 1
                                                  22:     _Tick_1638400: .space 1
                                                  23:     _Tick_3276800: .space 1
                                                  24:           .text
                                                  25:           .global _Ticks
                                                  26:     _Ticks:     
00133A  EC2954     INC 0x954                      27:    	inc _Tick
00133C  AE0954     BTSS 0x954, #0                 28:    	btss _Tick, #0
00133E  AA0956     BTG 0x956, #0                  29:    	btg _Tick_100, #0
001340  AE2954     BTSS 0x954, #1                 30:    	btss _Tick, #1
001342  AA0957     BTG 0x957, #0                  31:    	btg _Tick_200, #0
001344  AE4954     BTSS 0x954, #2                 32:    	btss _Tick, #2
001346  AA0958     BTG 0x958, #0                  33:    	btg _Tick_400, #0
001348  AE6954     BTSS 0x954, #3                 34:    	btss _Tick, #3
00134A  AA0959     BTG 0x959, #0                  35:    	btg _Tick_800, #0
00134C  060000     RETURN                         36:    	return
                                                  37:     .end
                                                  38:    
---  C:/Marcin Dec/private/Segway/Segway 19.07.15.X/Pid_s.s  --------------------------------------------
                                                  1:     ;struct Pid
                                                  2:     ;{
                                                  3:     ;   // external
                                                  4:     ;	0 int kp;
                                                  5:     ;	2 int ki;
                                                  6:     ;	4 int kd;
                                                  7:     ;	6 int offset;
                                                  8:     ;	8 int min;
                                                  9:     ;	10 int max;
                                                  10:    ;   12 int inverse;
                                                  11:    ;   // internal
                                                  12:    ;	14 long long int prevI;
                                                  13:    ;   22 int prevIn;
                                                  14:    ;}
                                                  15:    
                                                  16:    ;int PidExec(int in, struct Pid* pid)
                                                  17:    ;{
                                                  18:    ;	int out;
                                                  19:    ;
                                                  20:    ;	i += in * (pid->ki);
                                                  21:    ;	p = in * (pid->kp);
                                                  22:    ;	d = (in - prevIn) * (pid->kd);
                                                  23:    ;	prevIn = in;
                                                  24:    ;	out = p + i + d;
                                                  25:    ;	out >>= 16;
                                                  26:    ;	return out + pid->offset;
                                                  27:    ;}
                                                  28:     .global _PidExec
                                                  29:    _PidExec:
                                                  30:        ;;;;;;;;;;; siple or inverse control ;;;;;;;;;;;;;;;;;;;;;;;;
                                                  31:        ;mov [w2+12], w2         ; fetch previous i value to w2
                                                  32:        ;lac w2, #7, a           ; load previous i value to accumulator
                                                  33:        ;mov w2, w2
0012AA  9001E2     MOV [W2+12], W3                34:        mov [w2+12], w3          ; fetch inverse value to w3
0012AC  E00003     CP0 W3                         35:        cp0 w3                   ; compare inverse value with 0
0012AE  3C0002     BRA GT, 0x12B4                 36:        bra gt, INVERSE          ; if inverse value >0 skip simple error computing
0012B0  508000     SUB W1, W0, W0                 37:        sub w1, w0, w0           ; compute direct error (setp - in)
0012B2  370001     BRA 0x12B6                     38:        bra DIRECT
                                                  39:    INVERSE:
0012B4  500001     SUB W0, W1, W0                 40:        sub w0, w1, w0           ; compute inverse error ( in - setp)
                                                  41:    DIRECT:
                                                  42:        ;;;;;;;;;;; Integral ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0012B6  4100EE     ADD W2, #0xE, W1               43:        add w2, #14, w1          ; to w2 load structure pointer inreased with 12 (prevI)
0012B8  200223     MOV #0x22, W3                  44:        mov #0x22, w3            ; load ACCA's address to w3
0012BA  7819B1     MOV [W1++], [W3++]             45:        mov [w1++], [w3++]       ; load ACCA with previous i value
0012BC  7819B1     MOV [W1++], [W3++]             46:        mov [w1++], [w3++]       ;
0012BE  784991     MOV.B [W1], [W3]               47:        mov.b [w1], [w3]         ;
0012C0  780200     MOV W0, W4                     48:    	mov w0, w4              ; load current in to w4
0012C2  900292     MOV [W2+2], W5                 49:    	mov [w2+2], w5          ; fetch ki to w5
0012C4  C00112     MAC W4*W5, A                   50:    	mac w4*w5, a            ; multiply current in with ki and accumulate
                                                  51:        ;sac a, #-7, w3          ; preserve current i value
0012C6  C38112     CLR B                          52:        clr b                    ; preserve current i value in ACCB
0012C8  CB8000     ADD B                          53:        add b                    ;
                                                  54:        ;;;;;;;;;;; Proportional ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0012CA  780292     MOV [W2], W5                   55:        mov [w2], w5            ; fetch kp to w5
0012CC  C00112     MAC W4*W5, A                   56:        mac w4*w5, a            ; multiply current in with kp and accumulate
                                                  57:        ;;;;;;;;;;; Derivative ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0012CE  9008B2     MOV [W2+22], W1                58:        mov [w2+22], w1         ; fetch prevIn value to w2
0012D0  9002A2     MOV [W2+4], W5                 59:        mov [w2+4], w5          ; fetch kd to w5
0012D2  520201     SUB W4, W1, W4                 60:        sub w4, w1, w4          ; subtract prevIn from current in and result load to w4
0012D4  C00112     MAC W4*W5, A                   61:        mac w4*w5, a            ; multiply difference (in-prevIn) with kd and accumulate
                                                  62:        ;;;;;;;;;;; Output limit ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0012D6  CC0480     SAC A, #-7, W0                 63:        sac a, #-7, w0          ; load PID result to w0
0012D8  9001B2     MOV [W2+6], W3                 64:        mov [w2+6], w3          ; fetch offset value
0012DA  400003     ADD W0, W3, W0                 65:        add w0, w3, w0          ; add offset to output
0012DC  900252     MOV [W2+10], W4                66:        mov [w2+10], w4         ; fetch max value
0012DE  520080     SUB W4, W0, W1                 67:        sub w4, w0, w1          ; subtract max - out to make comparison
0012E0  3C0002     BRA GT, 0x12E6                 68:        bra gt, OUT_LE_MAX      ; if out <= max jump to OUT_LT_MAX
0012E2  780004     MOV W4, W0                     69:        mov w4, w0              ; alter w0 with max
0012E4  37000A     BRA 0x12FA                     70:        bra OUT_EQ_MAX
                                                  71:    OUT_LE_MAX:
0012E6  900242     MOV [W2+8], W4                 72:        mov [w2+8], w4          ; fetch min value
0012E8  520080     SUB W4, W0, W1                 73:        sub w4, w0, w1          ; subtract max - out to make comparison
0012EA  350002     BRA LT, 0x12F0                 74:        bra lt, OUT_IN_RANGE    ; if out >= min jump to OUT_IN_RANGE
0012EC  780004     MOV W4, W0                     75:        mov w4, w0              ; alter w0 with min
0012EE  370005     BRA 0x12FA                     76:        bra OUT_EQ_MIN
                                                  77:    OUT_IN_RANGE:
                                                  78:        ;mov w3, [w2+12]         ; store current i value
                                                  79:        ;mov w2, w2
0012F0  4100EE     ADD W2, #0xE, W1               80:        add w2, #14, w1         ; to w2 load structure pointer inreased with 12 (prevI)
0012F2  200283     MOV #0x28, W3                  81:        mov #0x28, w3           ; load ACCB's address to w3
0012F4  7818B3     MOV [W3++], [W1++]             82:        mov [w3++], [w1++]      ; store current i value (ACCB)
0012F6  7818B3     MOV [W3++], [W1++]             83:        mov [w3++], [w1++]      ;
0012F8  7858B3     MOV.B [W3++], [W1++]           84:        mov.b [w3++], [w1++]    ;
                                                  85:    OUT_EQ_MAX:
                                                  86:    OUT_EQ_MIN:
                                                  87:    ;mov w1, w0		    ; to bypas Pid algorithm uncoment this and comment all the rest
0012FA  060000     RETURN                         88:      return
                                                  89:     .end
---  C:/Marcin Dec/private/Segway/Segway 19.07.15.X/Motor.c  --------------------------------------------
1:                 /**********************************************************************c
2:                 * Author: Marcin Dec
3:                 * Date: 11.08.2015
4:                 * FileName:        Motor.c
5:                 * Dependencies:    Header Motor.h
6:                 * Processor:       dsPIC30F6013A
7:                 * Compiler:        MPLAB® XC16 C Compiler
8:                 *
9:                 ************************************************************************/
10:                #include <p30f6013A.h>
11:                #include <math.h>
12:                #include "Globals.h"
13:                #include "Motors.h"
14:                #include "Pid.h"
15:                #include "ADC.h"
16:                
17:                //// Timer 2 period in microseconds ///////////////////////////////
18:                #define T2_PERIOD 50L
19:                //// Timer 2 postscaler factor ////////////////////////////////////
20:                #define T2_POST 1L
21:                //// Timer 2 reload value = 1474/////////////////////////////////////////
22:                #define T2_PR2 (T2_PERIOD)*(F_CY/T2_POST)/1000000L
23:                //// Step Motor microsteps ///////////////////////////////////////
24:                //#define MICSTEPS 64
25:                
26:                #define PI 3.1415926535897932384626433832795F
27:                //// Timer 2 postscaler register value ///////////////////////////
28:                #if (T2_POST == 256)
29:                	#define T2_TCKPS 3
30:                #elif (T2_POST == 64)
31:                	#define T2_TCKPS 2
32:                #elif (T2_POST == 8)
33:                	#define T2_TCKPS 1
34:                #elif (T2_POST == 1)
35:                	#define T2_TCKPS 0
36:                #else
37:                	#error "T2_POST must be selected from set {1, 8, 64, 256} "
38:                #endif
39:                
40:                
41:                
42:                
43:                //unsigned int DecaySin = 0;
44:                //unsigned int DecayCos = 10;
45:                
46:                //int Rev = 32000;
47:                //int Presc = 0;				// Revolution control prescaler
48:                //int MicStep = 0;			// Sine-Cosine look-up array index (MicStepArray[])
49:                //int MICSTEPS = 16;
50:                //int StepIndx = 0;
51:                //int StepIncLatch = 1;
52:                //int StepInc = 0;
53:                //int PrescVal = 0;
54:                //int PrescValLatch = 1250;
55:                //int SpeedAbs = 0;
56:                //int Speed = 0;
57:                //int Direction = 1;
58:                //int Present = 0;
59:                //int SpeedChange = 1;
60:                //int Tick = 0;
61:                //int PhaseAfwd = 1;
62:                //int PhaseArev = 0;
63:                //int PhaseBfwd = 1;
64:                int debug = 0;
65:                int DebugSet = 5;
66:                int ADCon1_m;
67:                int temp;
68:                
69:                const int MICSTEPS = 16;
70:                const int SPEED_SLEWRATE = 1;
71:                extern __psv__ unsigned int SPEED_CURVE[251][3] __attribute__((space(psv)));
72:                extern const    int __attribute__((space(auto_psv),aligned)) Sin90[17];
73:                extern const    int __attribute__((space(auto_psv),aligned)) Cos90[17];
74:                extern void Tick(void);
75:                //unsigned int Sin90[17]; //MICSTEPS + 1
76:                //unsigned int Cos90[17]; //MICSTEPS + 1
77:                
78:                struct Motor
79:                {
80:                    int StepPresc;  // = 0;			// Micro step prescaler counter
81:                    int MicStep;    // = 0;			// Micro step counter
82:                    int StepIncLatch;   // = 1;                 // Micro step increment latch register
83:                    int StepInc;    // = 0;                     // Micro step increment
84:                    int StepPrescVal;   // = 0;                 // Micro step prescaler compare value
85:                    int StepPrescValLatch;  // = 1250;          // Micro step prescaler compare value latch register
86:                    int SpeedAbs;   // = 0;                     // Current motor speed absolute value
87:                    int Speed;  // = 0;                         // Current motor speed
88:                    int InputSpeed;  // = 0;                    // Input speed from external
89:                    int Direction;  // = 1;                     // Direction auxiliary variable
90:                    unsigned int DecaySin; // = 0;              // Decay % value for rising slope
91:                    unsigned int DecayCos; // = 10;             // Decay % value for falling slope
92:                    unsigned int Oc84rs; // = 0;                // Decay control auxiliary register
93:                    unsigned int Oc73rs; // = 0;                // Decay control auxiliary register
94:                    unsigned int Oc62rs; // = 0;                // Decay control auxiliary register
95:                    unsigned int Oc51rs; // = 0;                // Decay control auxiliary register
96:                    unsigned int Oc84r; // = 0;                 // Decay control auxiliary register
97:                    unsigned int Oc73r; // = 0;                 // Decay control auxiliary register
98:                    unsigned int Oc62r; // = 0;                 // Decay control auxiliary register
99:                    unsigned int Oc51r; // = 0;                 // Decay control auxiliary register
100:               }
101:               MotorLeft = {0, 0, 1, 0, 0, 1250, 0, 0, 50, 1, 10,0,0,0,0,0,0,0,0},
102:               MotorRight = {0, 0, 1, 0, 0, 1250, 0, 0, 0, 1, 10,0,0,0,0,0,0,0,0};
103:               
104:               //unsigned long int MicStepArray[17]; //  [MICSTEPS+1]
105:               //union
106:               //{
107:               //	struct
108:               //	{
109:               //		unsigned int Sin90;
110:               //		unsigned int Cos90;
111:               //	} MicStepStruct;
112:               //	unsigned long int MicStep;
113:               //} MicStepUnion;
114:               //#define INP MicStepUnion.MicStepStruct
115:               //#define MST MicStepUnion
116:               
117:               void SpeedSlewRate(struct Motor* motor )
118:               {
0007D4  FA0002     LNK #0x2
0007D6  780F00     MOV W0, [W14]
119:                   if(motor->InputSpeed > motor->Speed)
0007D8  78001E     MOV [W14], W0
0007DA  900880     MOV [W0+16], W1
0007DC  78001E     MOV [W14], W0
0007DE  900070     MOV [W0+14], W0
0007E0  508F80     SUB W1, W0, [W15]
0007E2  340011     BRA LE, 0x806
120:                   {
121:                       motor->Speed += SPEED_SLEWRATE;
0007E4  78001E     MOV [W14], W0
0007E6  9000F0     MOV [W0+14], W1
0007E8  843E90     MOV 0x87D2, W0
0007EA  408080     ADD W1, W0, W1
0007EC  78001E     MOV [W14], W0
0007EE  980071     MOV W1, [W0+14]
122:                       if(motor->Speed > motor->InputSpeed)
0007F0  78001E     MOV [W14], W0
0007F2  9000F0     MOV [W0+14], W1
0007F4  78001E     MOV [W14], W0
0007F6  900800     MOV [W0+16], W0
0007F8  508F80     SUB W1, W0, [W15]
0007FA  34001B     BRA LE, 0x832
123:                           motor->Speed = motor->InputSpeed;
0007FC  78001E     MOV [W14], W0
0007FE  900880     MOV [W0+16], W1
000800  78001E     MOV [W14], W0
000802  980071     MOV W1, [W0+14]
000804  370016     BRA 0x832
124:                   }
125:                   else if(motor->InputSpeed < motor->Speed)
000806  78001E     MOV [W14], W0
000808  900880     MOV [W0+16], W1
00080A  78001E     MOV [W14], W0
00080C  900070     MOV [W0+14], W0
00080E  508F80     SUB W1, W0, [W15]
000810  3D0010     BRA GE, 0x832
126:                   {
127:                       motor->Speed -= SPEED_SLEWRATE;
000812  78001E     MOV [W14], W0
000814  9000F0     MOV [W0+14], W1
000816  843E90     MOV 0x87D2, W0
000818  508080     SUB W1, W0, W1
00081A  78001E     MOV [W14], W0
00081C  980071     MOV W1, [W0+14]
128:                       if(motor->Speed < motor->InputSpeed)
00081E  78001E     MOV [W14], W0
000820  9000F0     MOV [W0+14], W1
000822  78001E     MOV [W14], W0
000824  900800     MOV [W0+16], W0
000826  508F80     SUB W1, W0, [W15]
000828  3D0004     BRA GE, 0x832
129:                           motor->Speed = motor->InputSpeed;
00082A  78001E     MOV [W14], W0
00082C  900880     MOV [W0+16], W1
00082E  78001E     MOV [W14], W0
000830  980071     MOV W1, [W0+14]
130:                   }
131:               }
000832  FA8000     ULNK
000834  060000     RETURN
132:               inline void MotorRightDecayLoad(void)
133:               {
000836  FA0000     LNK #0x0
134:                   if(MotorRight.MicStep/MICSTEPS == 0)		// sin >0, cos >0
000838  8048A1     MOV 0x914, W1
00083A  843E80     MOV 0x87D0, W0
00083C  780100     MOV W0, W2
00083E  090011     REPEAT #0x11
000840  D80082     DIV.SW W1, W2
000842  E00000     CP0 W0
000844  3A0009     BRA NZ, 0x858
135:                   {
136:                       OC7R = MotorRight.Oc73r;
000846  8049A0     MOV 0x934, W0
000848  880D30     MOV W0, OC7R
137:                       OC7RS = MotorRight.Oc73rs;
00084A  804960     MOV 0x92C, W0
00084C  880D20     MOV W0, OC7RS
138:                       OC5R = MotorRight.Oc51r;
00084E  8049C0     MOV 0x938, W0
000850  880CD0     MOV W0, OC5R
139:                       OC5RS = MotorRight.Oc51rs;
000852  804980     MOV 0x930, W0
000854  880CC0     MOV W0, OC5RS
000856  37002F     BRA 0x8B6
140:                   }
141:                   else if(MotorRight.MicStep/MICSTEPS == 1)		// sin >0, cos <0
000858  8048A1     MOV 0x914, W1
00085A  843E80     MOV 0x87D0, W0
00085C  780100     MOV W0, W2
00085E  090011     REPEAT #0x11
000860  D80082     DIV.SW W1, W2
000862  500FE1     SUB W0, #0x1, [W15]
000864  3A0009     BRA NZ, 0x878
142:                   {
143:                       OC7R = MotorRight.Oc73r;
000866  8049A0     MOV 0x934, W0
000868  880D30     MOV W0, OC7R
144:                       OC7RS = MotorRight.Oc73rs;
00086A  804960     MOV 0x92C, W0
00086C  880D20     MOV W0, OC7RS
145:                       OC6R = MotorRight.Oc62r;
00086E  8049B0     MOV 0x936, W0
000870  880D00     MOV W0, OC6R
146:                       OC6RS = MotorRight.Oc62rs;
000872  804970     MOV 0x92E, W0
000874  880CF0     MOV W0, OC6RS
000876  37001F     BRA 0x8B6
147:                   }
148:                   else if(MotorRight.MicStep/MICSTEPS == 2)		// sin <0, cos <0
000878  8048A1     MOV 0x914, W1
00087A  843E80     MOV 0x87D0, W0
00087C  780100     MOV W0, W2
00087E  090011     REPEAT #0x11
000880  D80082     DIV.SW W1, W2
000882  500FE2     SUB W0, #0x2, [W15]
000884  3A0009     BRA NZ, 0x898
149:                   {
150:                       OC8R = MotorRight.Oc84r;
000886  804990     MOV 0x932, W0
000888  880D60     MOV W0, OC8R
151:                       OC8RS = MotorRight.Oc84rs;
00088A  804950     MOV 0x92A, W0
00088C  880D50     MOV W0, OC8RS
152:                       OC6R = MotorRight.Oc62r;
00088E  8049B0     MOV 0x936, W0
000890  880D00     MOV W0, OC6R
153:                       OC6RS = MotorRight.Oc62rs;
000892  804970     MOV 0x92E, W0
000894  880CF0     MOV W0, OC6RS
000896  37000F     BRA 0x8B6
154:                   }
155:                   else if(MotorRight.MicStep/MICSTEPS == 3)		// sin <0, cos >0
000898  8048A1     MOV 0x914, W1
00089A  843E80     MOV 0x87D0, W0
00089C  780100     MOV W0, W2
00089E  090011     REPEAT #0x11
0008A0  D80082     DIV.SW W1, W2
0008A2  500FE3     SUB W0, #0x3, [W15]
0008A4  3A0008     BRA NZ, 0x8B6
156:                   {
157:                       OC8R = MotorRight.Oc84r;
0008A6  804990     MOV 0x932, W0
0008A8  880D60     MOV W0, OC8R
158:                       OC8RS = MotorRight.Oc84rs;
0008AA  804950     MOV 0x92A, W0
0008AC  880D50     MOV W0, OC8RS
159:                       OC5R = MotorRight.Oc51r;
0008AE  8049C0     MOV 0x938, W0
0008B0  880CD0     MOV W0, OC5R
160:                       OC5RS = MotorRight.Oc51rs;
0008B2  804980     MOV 0x930, W0
0008B4  880CC0     MOV W0, OC5RS
161:                   }
162:               }
0008B6  FA8000     ULNK
0008B8  060000     RETURN
163:               
164:               inline void MotorLeftDecayLoad(void)
165:               {
0008BA  FA0000     LNK #0x0
166:                   if(MotorLeft.MicStep/MICSTEPS == 0)			// sin >0, cos >0
0008BC  804761     MOV 0x8EC, W1
0008BE  843E80     MOV 0x87D0, W0
0008C0  780100     MOV W0, W2
0008C2  090011     REPEAT #0x11
0008C4  D80082     DIV.SW W1, W2
0008C6  E00000     CP0 W0
0008C8  3A0009     BRA NZ, 0x8DC
167:                   {
168:                       OC3R = MotorLeft.Oc73r;
0008CA  804860     MOV 0x90C, W0
0008CC  880C70     MOV W0, OC3R
169:                       OC3RS = MotorLeft.Oc73rs;
0008CE  804820     MOV 0x904, W0
0008D0  880C60     MOV W0, OC3RS
170:                       OC1R = MotorLeft.Oc51r;
0008D2  804880     MOV 0x910, W0
0008D4  880C10     MOV W0, OC1R
171:                       OC1RS = MotorLeft.Oc51rs;
0008D6  804840     MOV 0x908, W0
0008D8  880C00     MOV W0, OC1RS
0008DA  37002F     BRA 0x93A
172:                   }
173:                   else if(MotorLeft.MicStep/MICSTEPS == 1)		// sin >0, cos <0
0008DC  804761     MOV 0x8EC, W1
0008DE  843E80     MOV 0x87D0, W0
0008E0  780100     MOV W0, W2
0008E2  090011     REPEAT #0x11
0008E4  D80082     DIV.SW W1, W2
0008E6  500FE1     SUB W0, #0x1, [W15]
0008E8  3A0009     BRA NZ, 0x8FC
174:                   {
175:                       OC3R = MotorLeft.Oc73r;
0008EA  804860     MOV 0x90C, W0
0008EC  880C70     MOV W0, OC3R
176:                       OC3RS = MotorLeft.Oc73rs;
0008EE  804820     MOV 0x904, W0
0008F0  880C60     MOV W0, OC3RS
177:                       OC2R = MotorLeft.Oc62r;
0008F2  804870     MOV 0x90E, W0
0008F4  880C40     MOV W0, OC2R
178:                       OC2RS = MotorLeft.Oc62rs;
0008F6  804830     MOV 0x906, W0
0008F8  880C30     MOV W0, OC2RS
0008FA  37001F     BRA 0x93A
179:                   }
180:                   else if(MotorLeft.MicStep/MICSTEPS == 2)		// sin <0, cos <0
0008FC  804761     MOV 0x8EC, W1
0008FE  843E80     MOV 0x87D0, W0
000900  780100     MOV W0, W2
000902  090011     REPEAT #0x11
000904  D80082     DIV.SW W1, W2
000906  500FE2     SUB W0, #0x2, [W15]
000908  3A0009     BRA NZ, 0x91C
181:                   {
182:                       OC4R = MotorLeft.Oc84r;
00090A  804850     MOV 0x90A, W0
00090C  880CA0     MOV W0, OC4R
183:                       OC4RS = MotorLeft.Oc84rs;
00090E  804810     MOV 0x902, W0
000910  880C90     MOV W0, OC4RS
184:                       OC2R = MotorLeft.Oc62r;
000912  804870     MOV 0x90E, W0
000914  880C40     MOV W0, OC2R
185:                       OC2RS = MotorLeft.Oc62rs;
000916  804830     MOV 0x906, W0
000918  880C30     MOV W0, OC2RS
00091A  37000F     BRA 0x93A
186:                   }
187:                   else if(MotorLeft.MicStep/MICSTEPS == 3)		// sin <0, cos >0
00091C  804761     MOV 0x8EC, W1
00091E  843E80     MOV 0x87D0, W0
000920  780100     MOV W0, W2
000922  090011     REPEAT #0x11
000924  D80082     DIV.SW W1, W2
000926  500FE3     SUB W0, #0x3, [W15]
000928  3A0008     BRA NZ, 0x93A
188:                   {
189:                       OC4R = MotorLeft.Oc84r;
00092A  804850     MOV 0x90A, W0
00092C  880CA0     MOV W0, OC4R
190:                       OC4RS = MotorLeft.Oc84rs;
00092E  804810     MOV 0x902, W0
000930  880C90     MOV W0, OC4RS
191:                       OC1R = MotorLeft.Oc51r;
000932  804880     MOV 0x910, W0
000934  880C10     MOV W0, OC1R
192:                       OC1RS = MotorLeft.Oc51rs;
000936  804840     MOV 0x908, W0
000938  880C00     MOV W0, OC1RS
193:                   }
194:               }
00093A  FA8000     ULNK
00093C  060000     RETURN
195:               inline void MotorDecayLoad(void)
196:               {
00093E  FA0000     LNK #0x0
197:                   MotorRightDecayLoad();
000940  07FF7A     RCALL MotorRightDecayLoad
198:                   MotorLeftDecayLoad();
000942  07FFBB     RCALL MotorLeftDecayLoad
199:               }
000944  FA8000     ULNK
000946  060000     RETURN
200:               //inline PidIterate(void)
201:               //{
202:               //    PidExec(ADCCSARight, setp, &PidCSAR)
203:               //}
204:               inline void MotorRightDriver(void)
205:               {
000948  FA0000     LNK #0x0
206:                   
207:               
208:                   if(MotorRight.MicStep/MICSTEPS == 0)			// sin >0, cos >0
00094A  8048A1     MOV 0x914, W1
00094C  843E80     MOV 0x87D0, W0
00094E  780100     MOV W0, W2
000950  090011     REPEAT #0x11
000952  D80082     DIV.SW W1, W2
000954  E00000     CP0 W0
000956  3A008B     BRA NZ, 0xA6E
209:                   {
210:                       // Phase A //////
211:                       // Present Sin = 0 and loaded next value, DecaySin
212:                       // Polarisation positive
213:                       //MST.MicStep = MicStepArray[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch];
214:                       if(MotorRight.Direction)
000958  804920     MOV 0x924, W0
00095A  E00000     CP0 W0
00095C  320013     BRA Z, 0x984
215:                       {
216:                            if(OC8CONbits.OCM != 0b110)
00095E  800D70     MOV OC8CON, W0
000960  600067     AND W0, #0x7, W0
000962  500FE6     SUB W0, #0x6, [W15]
000964  320005     BRA Z, 0x970
217:                            OC8CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000966  800D70     MOV OC8CON, W0
000968  A10000     BCLR W0, #0
00096A  A01000     BSET W0, #1
00096C  A02000     BSET W0, #2
00096E  880D70     MOV W0, OC8CON
218:                            if(OC7CONbits.OCM != 0b101)
000970  800D40     MOV OC7CON, W0
000972  600067     AND W0, #0x7, W0
000974  500FE5     SUB W0, #0x5, [W15]
000976  320018     BRA Z, 0x9A8
219:                            OC7CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
000978  800D40     MOV OC7CON, W0
00097A  A00000     BSET W0, #0
00097C  A11000     BCLR W0, #1
00097E  A02000     BSET W0, #2
000980  880D40     MOV W0, OC7CON
000982  370012     BRA 0x9A8
220:                       }
221:                       else
222:                       {
223:                           if(OC6CONbits.OCM != 0b110)
000984  800D10     MOV OC6CON, W0
000986  600067     AND W0, #0x7, W0
000988  500FE6     SUB W0, #0x6, [W15]
00098A  320005     BRA Z, 0x996
224:                           OC6CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
00098C  800D10     MOV OC6CON, W0
00098E  A10000     BCLR W0, #0
000990  A01000     BSET W0, #1
000992  A02000     BSET W0, #2
000994  880D10     MOV W0, OC6CON
225:                           if(OC5CONbits.OCM != 0b101)
000996  800CE0     MOV OC5CON, W0
000998  600067     AND W0, #0x7, W0
00099A  500FE5     SUB W0, #0x5, [W15]
00099C  320005     BRA Z, 0x9A8
226:                           OC5CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
00099E  800CE0     MOV OC5CON, W0
0009A0  A00000     BSET W0, #0
0009A2  A11000     BCLR W0, #1
0009A4  A02000     BSET W0, #2
0009A6  880CE0     MOV W0, OC5CON
227:                       }
228:                       OC8RS = PidExec(ADCCSARight, Sin90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSAR);
0009A8  8048A1     MOV 0x914, W1
0009AA  843E80     MOV 0x87D0, W0
0009AC  780180     MOV W0, W3
0009AE  090011     REPEAT #0x11
0009B0  D80083     DIV.SW W1, W3
0009B2  FD0080     EXCH W0, W1
0009B4  780080     MOV W0, W1
0009B6  8048B0     MOV 0x916, W0
0009B8  408000     ADD W1, W0, W0
0009BA  400080     ADD W0, W0, W1
0009BC  287A20     MOV #0x87A2, W0
0009BE  408000     ADD W1, W0, W0
0009C0  780090     MOV [W0], W1
0009C2  8044E0     MOV ADCCSARight, W0
0009C4  208002     MOV #0x800, W2
0009C6  070471     RCALL _PidExec
0009C8  880D50     MOV W0, OC8RS
229:                       MotorRight.Oc73r = OC8RS;
0009CA  800D50     MOV OC8RS, W0
0009CC  8849A0     MOV W0, 0x934
230:                       if((MotorRight.Oc73r + 10) >= PR2)
0009CE  8049A0     MOV 0x934, W0
0009D0  4000EA     ADD W0, #0xA, W1
0009D2  800860     MOV PR2, W0
0009D4  508F80     SUB W1, W0, [W15]
0009D6  390006     BRA NC, 0x9E4
231:                           OC7CONbits.OCM = 0b000;                 // Disable fast deccay
0009D8  800D40     MOV OC7CON, W0
0009DA  A10000     BCLR W0, #0
0009DC  A11000     BCLR W0, #1
0009DE  A12000     BCLR W0, #2
0009E0  880D40     MOV W0, OC7CON
0009E2  370005     BRA 0x9EE
232:                       else OC7CONbits.OCM = 0b101;
0009E4  800D40     MOV OC7CON, W0
0009E6  A00000     BSET W0, #0
0009E8  A11000     BCLR W0, #1
0009EA  A02000     BSET W0, #2
0009EC  880D40     MOV W0, OC7CON
233:                       MotorRight.Oc73rs = 2 + MotorRight.Oc73r + (PR2 - MotorRight.Oc73r) * MotorRight.DecaySin / 100;
0009EE  8049A2     MOV 0x934, W2
0009F0  800861     MOV PR2, W1
0009F2  8049A0     MOV 0x934, W0
0009F4  508080     SUB W1, W0, W1
0009F6  804930     MOV 0x926, W0
0009F8  B98800     MUL.SS W1, W0, W0
0009FA  780080     MOV W0, W1
0009FC  200640     MOV #0x64, W0
0009FE  780180     MOV W0, W3
000A00  090011     REPEAT #0x11
000A02  D88083     DIV.UW W1, W3
000A04  410000     ADD W2, W0, W0
000A06  E88000     INC2 W0, W0
000A08  884960     MOV W0, 0x92C
234:                       // Phase B //////
235:                       // Present Cos = 1 and loaded next value, DecayCos
236:                       OC6RS = PidExec(ADCCSBRight,Cos90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSBR);
000A0A  8048A1     MOV 0x914, W1
000A0C  843E80     MOV 0x87D0, W0
000A0E  780100     MOV W0, W2
000A10  090011     REPEAT #0x11
000A12  D80082     DIV.SW W1, W2
000A14  FD0080     EXCH W0, W1
000A16  780080     MOV W0, W1
000A18  8048B0     MOV 0x916, W0
000A1A  408000     ADD W1, W0, W0
000A1C  400080     ADD W0, W0, W1
000A1E  287800     MOV #0x8780, W0
000A20  408000     ADD W1, W0, W0
000A22  780090     MOV [W0], W1
000A24  8044F0     MOV ADCCSBRight, W0
000A26  208182     MOV #0x818, W2
000A28  070440     RCALL _PidExec
000A2A  880CF0     MOV W0, OC6RS
237:                       MotorRight.Oc51r = OC6RS;
000A2C  800CF0     MOV OC6RS, W0
000A2E  8849C0     MOV W0, 0x938
238:                       if((MotorRight.Oc51r + 10) >= PR2)
000A30  8049C0     MOV 0x938, W0
000A32  4000EA     ADD W0, #0xA, W1
000A34  800860     MOV PR2, W0
000A36  508F80     SUB W1, W0, [W15]
000A38  390006     BRA NC, 0xA46
239:                           OC5CONbits.OCM = 0b000;                 // Disable fast deccay
000A3A  800CE0     MOV OC5CON, W0
000A3C  A10000     BCLR W0, #0
000A3E  A11000     BCLR W0, #1
000A40  A12000     BCLR W0, #2
000A42  880CE0     MOV W0, OC5CON
000A44  370005     BRA 0xA50
240:                       else OC5CONbits.OCM = 0b101;
000A46  800CE0     MOV OC5CON, W0
000A48  A00000     BSET W0, #0
000A4A  A11000     BCLR W0, #1
000A4C  A02000     BSET W0, #2
000A4E  880CE0     MOV W0, OC5CON
241:                       MotorRight.Oc51rs = 2 + MotorRight.Oc51r + (PR2 - MotorRight.Oc51r) * MotorRight.DecayCos / 100;
000A50  8049C2     MOV 0x938, W2
000A52  800861     MOV PR2, W1
000A54  8049C0     MOV 0x938, W0
000A56  508080     SUB W1, W0, W1
000A58  804940     MOV 0x928, W0
000A5A  B98800     MUL.SS W1, W0, W0
000A5C  780080     MOV W0, W1
000A5E  200640     MOV #0x64, W0
000A60  780180     MOV W0, W3
000A62  090011     REPEAT #0x11
000A64  D88083     DIV.UW W1, W3
000A66  410000     ADD W2, W0, W0
000A68  E88000     INC2 W0, W0
000A6A  884980     MOV W0, 0x930
000A6C  3701B5     BRA 0xDD8
242:                   }
243:                   else if(MotorRight.MicStep/MICSTEPS == 1)		// sin >0, cos <0
000A6E  8048A1     MOV 0x914, W1
000A70  843E80     MOV 0x87D0, W0
000A72  780100     MOV W0, W2
000A74  090011     REPEAT #0x11
000A76  D80082     DIV.SW W1, W2
000A78  500FE1     SUB W0, #0x1, [W15]
000A7A  3A008B     BRA NZ, 0xB92
244:                   {
245:                       // Phase A //////
246:                       // Present Cos = 1 and loaded next value, DecayCos
247:                       //MST.MicStep = MicStepArray[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch];
248:                       if(MotorRight.Direction)
000A7C  804920     MOV 0x924, W0
000A7E  E00000     CP0 W0
000A80  320013     BRA Z, 0xAA8
249:                       {
250:                           if(OC6CONbits.OCM != 0b101)
000A82  800D10     MOV OC6CON, W0
000A84  600067     AND W0, #0x7, W0
000A86  500FE5     SUB W0, #0x5, [W15]
000A88  320005     BRA Z, 0xA94
251:                           OC6CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
000A8A  800D10     MOV OC6CON, W0
000A8C  A00000     BSET W0, #0
000A8E  A11000     BCLR W0, #1
000A90  A02000     BSET W0, #2
000A92  880D10     MOV W0, OC6CON
252:                           if(OC5CONbits.OCM != 0b110)
000A94  800CE0     MOV OC5CON, W0
000A96  600067     AND W0, #0x7, W0
000A98  500FE6     SUB W0, #0x6, [W15]
000A9A  320018     BRA Z, 0xACC
253:                           OC5CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000A9C  800CE0     MOV OC5CON, W0
000A9E  A10000     BCLR W0, #0
000AA0  A01000     BSET W0, #1
000AA2  A02000     BSET W0, #2
000AA4  880CE0     MOV W0, OC5CON
000AA6  370012     BRA 0xACC
254:                       }
255:                       else
256:                       {
257:                            if(OC8CONbits.OCM != 0b110)
000AA8  800D70     MOV OC8CON, W0
000AAA  600067     AND W0, #0x7, W0
000AAC  500FE6     SUB W0, #0x6, [W15]
000AAE  320005     BRA Z, 0xABA
258:                            OC8CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000AB0  800D70     MOV OC8CON, W0
000AB2  A10000     BCLR W0, #0
000AB4  A01000     BSET W0, #1
000AB6  A02000     BSET W0, #2
000AB8  880D70     MOV W0, OC8CON
259:                            if(OC7CONbits.OCM != 0b101)
000ABA  800D40     MOV OC7CON, W0
000ABC  600067     AND W0, #0x7, W0
000ABE  500FE5     SUB W0, #0x5, [W15]
000AC0  320005     BRA Z, 0xACC
260:                            OC7CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
000AC2  800D40     MOV OC7CON, W0
000AC4  A00000     BSET W0, #0
000AC6  A11000     BCLR W0, #1
000AC8  A02000     BSET W0, #2
000ACA  880D40     MOV W0, OC7CON
261:                       }
262:                       OC8RS = PidExec(ADCCSARight,Cos90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSAR);
000ACC  8048A1     MOV 0x914, W1
000ACE  843E80     MOV 0x87D0, W0
000AD0  780180     MOV W0, W3
000AD2  090011     REPEAT #0x11
000AD4  D80083     DIV.SW W1, W3
000AD6  FD0080     EXCH W0, W1
000AD8  780080     MOV W0, W1
000ADA  8048B0     MOV 0x916, W0
000ADC  408000     ADD W1, W0, W0
000ADE  400080     ADD W0, W0, W1
000AE0  287800     MOV #0x8780, W0
000AE2  408000     ADD W1, W0, W0
000AE4  780090     MOV [W0], W1
000AE6  8044E0     MOV ADCCSARight, W0
000AE8  208002     MOV #0x800, W2
000AEA  0703DF     RCALL _PidExec
000AEC  880D50     MOV W0, OC8RS
263:                       MotorRight.Oc73r = OC8RS;
000AEE  800D50     MOV OC8RS, W0
000AF0  8849A0     MOV W0, 0x934
264:                       if((MotorRight.Oc73r + 10) >= PR2)
000AF2  8049A0     MOV 0x934, W0
000AF4  4000EA     ADD W0, #0xA, W1
000AF6  800860     MOV PR2, W0
000AF8  508F80     SUB W1, W0, [W15]
000AFA  390006     BRA NC, 0xB08
265:                           OC7CONbits.OCM = 0b000;                 // Disable fast deccay
000AFC  800D40     MOV OC7CON, W0
000AFE  A10000     BCLR W0, #0
000B00  A11000     BCLR W0, #1
000B02  A12000     BCLR W0, #2
000B04  880D40     MOV W0, OC7CON
000B06  370005     BRA 0xB12
266:                       else OC7CONbits.OCM = 0b101;
000B08  800D40     MOV OC7CON, W0
000B0A  A00000     BSET W0, #0
000B0C  A11000     BCLR W0, #1
000B0E  A02000     BSET W0, #2
000B10  880D40     MOV W0, OC7CON
267:                       MotorRight.Oc73rs = 2 + MotorRight.Oc73r + (PR2 - MotorRight.Oc73r) * MotorRight.DecayCos / 100;
000B12  8049A2     MOV 0x934, W2
000B14  800861     MOV PR2, W1
000B16  8049A0     MOV 0x934, W0
000B18  508080     SUB W1, W0, W1
000B1A  804940     MOV 0x928, W0
000B1C  B98800     MUL.SS W1, W0, W0
000B1E  780080     MOV W0, W1
000B20  200640     MOV #0x64, W0
000B22  780180     MOV W0, W3
000B24  090011     REPEAT #0x11
000B26  D88083     DIV.UW W1, W3
000B28  410000     ADD W2, W0, W0
000B2A  E88000     INC2 W0, W0
000B2C  884960     MOV W0, 0x92C
268:                       // Phase B //////
269:                       // Present Sin = 0 and loaded next value, DecaySin
270:                       // Polarisation negative
271:               
272:                       OC5RS = PidExec(ADCCSBRight, Sin90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSBR);
000B2E  8048A1     MOV 0x914, W1
000B30  843E80     MOV 0x87D0, W0
000B32  780100     MOV W0, W2
000B34  090011     REPEAT #0x11
000B36  D80082     DIV.SW W1, W2
000B38  FD0080     EXCH W0, W1
000B3A  780080     MOV W0, W1
000B3C  8048B0     MOV 0x916, W0
000B3E  408000     ADD W1, W0, W0
000B40  400080     ADD W0, W0, W1
000B42  287A20     MOV #0x87A2, W0
000B44  408000     ADD W1, W0, W0
000B46  780090     MOV [W0], W1
000B48  8044F0     MOV ADCCSBRight, W0
000B4A  208182     MOV #0x818, W2
000B4C  0703AE     RCALL _PidExec
000B4E  880CC0     MOV W0, OC5RS
273:                       MotorRight.Oc62r = OC5RS;
000B50  800CC0     MOV OC5RS, W0
000B52  8849B0     MOV W0, 0x936
274:                       if((MotorRight.Oc62r + 10) >= PR2)
000B54  8049B0     MOV 0x936, W0
000B56  4000EA     ADD W0, #0xA, W1
000B58  800860     MOV PR2, W0
000B5A  508F80     SUB W1, W0, [W15]
000B5C  390006     BRA NC, 0xB6A
275:                           OC6CONbits.OCM = 0b000;                 // Disable fast deccay
000B5E  800D10     MOV OC6CON, W0
000B60  A10000     BCLR W0, #0
000B62  A11000     BCLR W0, #1
000B64  A12000     BCLR W0, #2
000B66  880D10     MOV W0, OC6CON
000B68  370005     BRA 0xB74
276:                       else OC6CONbits.OCM = 0b101;
000B6A  800D10     MOV OC6CON, W0
000B6C  A00000     BSET W0, #0
000B6E  A11000     BCLR W0, #1
000B70  A02000     BSET W0, #2
000B72  880D10     MOV W0, OC6CON
277:                       MotorRight.Oc62rs = 2 + MotorRight.Oc62r + (PR2 - MotorRight.Oc62r) * MotorRight.DecaySin / 100;
000B74  8049B2     MOV 0x936, W2
000B76  800861     MOV PR2, W1
000B78  8049B0     MOV 0x936, W0
000B7A  508080     SUB W1, W0, W1
000B7C  804930     MOV 0x926, W0
000B7E  B98800     MUL.SS W1, W0, W0
000B80  780080     MOV W0, W1
000B82  200640     MOV #0x64, W0
000B84  780180     MOV W0, W3
000B86  090011     REPEAT #0x11
000B88  D88083     DIV.UW W1, W3
000B8A  410000     ADD W2, W0, W0
000B8C  E88000     INC2 W0, W0
000B8E  884970     MOV W0, 0x92E
000B90  370123     BRA 0xDD8
278:                   }
279:                   else if(MotorRight.MicStep/MICSTEPS == 2)		// sin <0, cos <0
000B92  8048A1     MOV 0x914, W1
000B94  843E80     MOV 0x87D0, W0
000B96  780100     MOV W0, W2
000B98  090011     REPEAT #0x11
000B9A  D80082     DIV.SW W1, W2
000B9C  500FE2     SUB W0, #0x2, [W15]
000B9E  3A008B     BRA NZ, 0xCB6
280:                   {
281:                       // Phase A //////
282:                       // Present Sin = 0 and loaded next value, DecaySin
283:                       // Polarisation negative
284:                       //MST.MicStep = MicStepArray[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch];
285:                       if(MotorRight.Direction)
000BA0  804920     MOV 0x924, W0
000BA2  E00000     CP0 W0
000BA4  320013     BRA Z, 0xBCC
286:                       {
287:                           if(OC7CONbits.OCM != 0b110)
000BA6  800D40     MOV OC7CON, W0
000BA8  600067     AND W0, #0x7, W0
000BAA  500FE6     SUB W0, #0x6, [W15]
000BAC  320005     BRA Z, 0xBB8
288:                           OC7CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000BAE  800D40     MOV OC7CON, W0
000BB0  A10000     BCLR W0, #0
000BB2  A01000     BSET W0, #1
000BB4  A02000     BSET W0, #2
000BB6  880D40     MOV W0, OC7CON
289:                           if(OC8CONbits.OCM != 0b101)
000BB8  800D70     MOV OC8CON, W0
000BBA  600067     AND W0, #0x7, W0
000BBC  500FE5     SUB W0, #0x5, [W15]
000BBE  320018     BRA Z, 0xBF0
290:                           OC8CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
000BC0  800D70     MOV OC8CON, W0
000BC2  A00000     BSET W0, #0
000BC4  A11000     BCLR W0, #1
000BC6  A02000     BSET W0, #2
000BC8  880D70     MOV W0, OC8CON
000BCA  370012     BRA 0xBF0
291:                       }
292:                       else
293:                       {
294:                           if(OC6CONbits.OCM != 0b101)
000BCC  800D10     MOV OC6CON, W0
000BCE  600067     AND W0, #0x7, W0
000BD0  500FE5     SUB W0, #0x5, [W15]
000BD2  320005     BRA Z, 0xBDE
295:                           OC6CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
000BD4  800D10     MOV OC6CON, W0
000BD6  A00000     BSET W0, #0
000BD8  A11000     BCLR W0, #1
000BDA  A02000     BSET W0, #2
000BDC  880D10     MOV W0, OC6CON
296:                           if(OC5CONbits.OCM != 0b110)
000BDE  800CE0     MOV OC5CON, W0
000BE0  600067     AND W0, #0x7, W0
000BE2  500FE6     SUB W0, #0x6, [W15]
000BE4  320005     BRA Z, 0xBF0
297:                           OC5CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000BE6  800CE0     MOV OC5CON, W0
000BE8  A10000     BCLR W0, #0
000BEA  A01000     BSET W0, #1
000BEC  A02000     BSET W0, #2
000BEE  880CE0     MOV W0, OC5CON
298:                       }
299:                       OC7RS = PidExec(ADCCSARight, Sin90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSAR);
000BF0  8048A1     MOV 0x914, W1
000BF2  843E80     MOV 0x87D0, W0
000BF4  780180     MOV W0, W3
000BF6  090011     REPEAT #0x11
000BF8  D80083     DIV.SW W1, W3
000BFA  FD0080     EXCH W0, W1
000BFC  780080     MOV W0, W1
000BFE  8048B0     MOV 0x916, W0
000C00  408000     ADD W1, W0, W0
000C02  400080     ADD W0, W0, W1
000C04  287A20     MOV #0x87A2, W0
000C06  408000     ADD W1, W0, W0
000C08  780090     MOV [W0], W1
000C0A  8044E0     MOV ADCCSARight, W0
000C0C  208002     MOV #0x800, W2
000C0E  07034D     RCALL _PidExec
000C10  880D20     MOV W0, OC7RS
300:                       MotorRight.Oc84r = OC7RS;
000C12  800D20     MOV OC7RS, W0
000C14  884990     MOV W0, 0x932
301:                       if((MotorRight.Oc84r + 10) >= PR2)
000C16  804990     MOV 0x932, W0
000C18  4000EA     ADD W0, #0xA, W1
000C1A  800860     MOV PR2, W0
000C1C  508F80     SUB W1, W0, [W15]
000C1E  390006     BRA NC, 0xC2C
302:                           OC8CONbits.OCM = 0b000;                 // Disable fast deccay
000C20  800D70     MOV OC8CON, W0
000C22  A10000     BCLR W0, #0
000C24  A11000     BCLR W0, #1
000C26  A12000     BCLR W0, #2
000C28  880D70     MOV W0, OC8CON
000C2A  370005     BRA 0xC36
303:                       else OC8CONbits.OCM = 0b101;
000C2C  800D70     MOV OC8CON, W0
000C2E  A00000     BSET W0, #0
000C30  A11000     BCLR W0, #1
000C32  A02000     BSET W0, #2
000C34  880D70     MOV W0, OC8CON
304:                       MotorRight.Oc84rs = 2 + MotorRight.Oc84r + (PR2 - MotorRight.Oc84r) * MotorRight.DecaySin / 100;
000C36  804992     MOV 0x932, W2
000C38  800861     MOV PR2, W1
000C3A  804990     MOV 0x932, W0
000C3C  508080     SUB W1, W0, W1
000C3E  804930     MOV 0x926, W0
000C40  B98800     MUL.SS W1, W0, W0
000C42  780080     MOV W0, W1
000C44  200640     MOV #0x64, W0
000C46  780180     MOV W0, W3
000C48  090011     REPEAT #0x11
000C4A  D88083     DIV.UW W1, W3
000C4C  410000     ADD W2, W0, W0
000C4E  E88000     INC2 W0, W0
000C50  884950     MOV W0, 0x92A
305:                       // Phase B //////
306:                       // Present Cos = 1 and loaded next value, DecayCos
307:                       OC5RS = PidExec(ADCCSBRight, Cos90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSBR);
000C52  8048A1     MOV 0x914, W1
000C54  843E80     MOV 0x87D0, W0
000C56  780100     MOV W0, W2
000C58  090011     REPEAT #0x11
000C5A  D80082     DIV.SW W1, W2
000C5C  FD0080     EXCH W0, W1
000C5E  780080     MOV W0, W1
000C60  8048B0     MOV 0x916, W0
000C62  408000     ADD W1, W0, W0
000C64  400080     ADD W0, W0, W1
000C66  287800     MOV #0x8780, W0
000C68  408000     ADD W1, W0, W0
000C6A  780090     MOV [W0], W1
000C6C  8044F0     MOV ADCCSBRight, W0
000C6E  208182     MOV #0x818, W2
000C70  07031C     RCALL _PidExec
000C72  880CC0     MOV W0, OC5RS
308:                       MotorRight.Oc62r = OC5RS;
000C74  800CC0     MOV OC5RS, W0
000C76  8849B0     MOV W0, 0x936
309:                       if((MotorRight.Oc62r + 10) >= PR2)
000C78  8049B0     MOV 0x936, W0
000C7A  4000EA     ADD W0, #0xA, W1
000C7C  800860     MOV PR2, W0
000C7E  508F80     SUB W1, W0, [W15]
000C80  390006     BRA NC, 0xC8E
310:                           OC6CONbits.OCM = 0b000;                 // Disable fast deccay
000C82  800D10     MOV OC6CON, W0
000C84  A10000     BCLR W0, #0
000C86  A11000     BCLR W0, #1
000C88  A12000     BCLR W0, #2
000C8A  880D10     MOV W0, OC6CON
000C8C  370005     BRA 0xC98
311:                       else OC6CONbits.OCM = 0b101;
000C8E  800D10     MOV OC6CON, W0
000C90  A00000     BSET W0, #0
000C92  A11000     BCLR W0, #1
000C94  A02000     BSET W0, #2
000C96  880D10     MOV W0, OC6CON
312:                       MotorRight.Oc62rs = 2 + MotorRight.Oc62r + (PR2 - MotorRight.Oc62r) * MotorRight.DecayCos / 100;
000C98  8049B2     MOV 0x936, W2
000C9A  800861     MOV PR2, W1
000C9C  8049B0     MOV 0x936, W0
000C9E  508080     SUB W1, W0, W1
000CA0  804940     MOV 0x928, W0
000CA2  B98800     MUL.SS W1, W0, W0
000CA4  780080     MOV W0, W1
000CA6  200640     MOV #0x64, W0
000CA8  780180     MOV W0, W3
000CAA  090011     REPEAT #0x11
000CAC  D88083     DIV.UW W1, W3
000CAE  410000     ADD W2, W0, W0
000CB0  E88000     INC2 W0, W0
000CB2  884970     MOV W0, 0x92E
000CB4  370091     BRA 0xDD8
313:                   }
314:                   else if(MotorRight.MicStep/MICSTEPS == 3)					// sin <0, cos >0
000CB6  8048A1     MOV 0x914, W1
000CB8  843E80     MOV 0x87D0, W0
000CBA  780100     MOV W0, W2
000CBC  090011     REPEAT #0x11
000CBE  D80082     DIV.SW W1, W2
000CC0  500FE3     SUB W0, #0x3, [W15]
000CC2  3A008A     BRA NZ, 0xDD8
315:                   {
316:                       // Phase A //////
317:                       // Present Cos = 1 and loaded next value, DecayCos
318:                       //MST.MicStep = MicStepArray[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch];
319:                       if(MotorRight.Direction)
000CC4  804920     MOV 0x924, W0
000CC6  E00000     CP0 W0
000CC8  320013     BRA Z, 0xCF0
320:                       {
321:                           if(OC6CONbits.OCM != 0b110)
000CCA  800D10     MOV OC6CON, W0
000CCC  600067     AND W0, #0x7, W0
000CCE  500FE6     SUB W0, #0x6, [W15]
000CD0  320005     BRA Z, 0xCDC
322:                           OC6CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000CD2  800D10     MOV OC6CON, W0
000CD4  A10000     BCLR W0, #0
000CD6  A01000     BSET W0, #1
000CD8  A02000     BSET W0, #2
000CDA  880D10     MOV W0, OC6CON
323:                           if(OC5CONbits.OCM != 0b101)
000CDC  800CE0     MOV OC5CON, W0
000CDE  600067     AND W0, #0x7, W0
000CE0  500FE5     SUB W0, #0x5, [W15]
000CE2  320018     BRA Z, 0xD14
324:                           OC5CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
000CE4  800CE0     MOV OC5CON, W0
000CE6  A00000     BSET W0, #0
000CE8  A11000     BCLR W0, #1
000CEA  A02000     BSET W0, #2
000CEC  880CE0     MOV W0, OC5CON
000CEE  370012     BRA 0xD14
325:                       }
326:                       else
327:                       {
328:                           if(OC7CONbits.OCM != 0b110)
000CF0  800D40     MOV OC7CON, W0
000CF2  600067     AND W0, #0x7, W0
000CF4  500FE6     SUB W0, #0x6, [W15]
000CF6  320005     BRA Z, 0xD02
329:                           OC7CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000CF8  800D40     MOV OC7CON, W0
000CFA  A10000     BCLR W0, #0
000CFC  A01000     BSET W0, #1
000CFE  A02000     BSET W0, #2
000D00  880D40     MOV W0, OC7CON
330:                           if(OC8CONbits.OCM != 0b101)
000D02  800D70     MOV OC8CON, W0
000D04  600067     AND W0, #0x7, W0
000D06  500FE5     SUB W0, #0x5, [W15]
000D08  320005     BRA Z, 0xD14
331:                           OC8CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
000D0A  800D70     MOV OC8CON, W0
000D0C  A00000     BSET W0, #0
000D0E  A11000     BCLR W0, #1
000D10  A02000     BSET W0, #2
000D12  880D70     MOV W0, OC8CON
332:                       }
333:                       OC7RS = PidExec(ADCCSARight, Cos90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSAR);
000D14  8048A1     MOV 0x914, W1
000D16  843E80     MOV 0x87D0, W0
000D18  780180     MOV W0, W3
000D1A  090011     REPEAT #0x11
000D1C  D80083     DIV.SW W1, W3
000D1E  FD0080     EXCH W0, W1
000D20  780080     MOV W0, W1
000D22  8048B0     MOV 0x916, W0
000D24  408000     ADD W1, W0, W0
000D26  400080     ADD W0, W0, W1
000D28  287800     MOV #0x8780, W0
000D2A  408000     ADD W1, W0, W0
000D2C  780090     MOV [W0], W1
000D2E  8044E0     MOV ADCCSARight, W0
000D30  208002     MOV #0x800, W2
000D32  0702BB     RCALL _PidExec
000D34  880D20     MOV W0, OC7RS
334:                       MotorRight.Oc84r = OC7RS;
000D36  800D20     MOV OC7RS, W0
000D38  884990     MOV W0, 0x932
335:                       if((MotorRight.Oc84r + 10) >= PR2)
000D3A  804990     MOV 0x932, W0
000D3C  4000EA     ADD W0, #0xA, W1
000D3E  800860     MOV PR2, W0
000D40  508F80     SUB W1, W0, [W15]
000D42  390006     BRA NC, 0xD50
336:                           OC8CONbits.OCM = 0b000;                 // Disable fast deccay
000D44  800D70     MOV OC8CON, W0
000D46  A10000     BCLR W0, #0
000D48  A11000     BCLR W0, #1
000D4A  A12000     BCLR W0, #2
000D4C  880D70     MOV W0, OC8CON
000D4E  370005     BRA 0xD5A
337:                       else OC8CONbits.OCM = 0b101;
000D50  800D70     MOV OC8CON, W0
000D52  A00000     BSET W0, #0
000D54  A11000     BCLR W0, #1
000D56  A02000     BSET W0, #2
000D58  880D70     MOV W0, OC8CON
338:                       MotorRight.Oc84rs = 2 + MotorRight.Oc84r + (PR2 - MotorRight.Oc84r) * MotorRight.DecayCos / 100;
000D5A  804992     MOV 0x932, W2
000D5C  800861     MOV PR2, W1
000D5E  804990     MOV 0x932, W0
000D60  508080     SUB W1, W0, W1
000D62  804940     MOV 0x928, W0
000D64  B98800     MUL.SS W1, W0, W0
000D66  780080     MOV W0, W1
000D68  200640     MOV #0x64, W0
000D6A  780180     MOV W0, W3
000D6C  090011     REPEAT #0x11
000D6E  D88083     DIV.UW W1, W3
000D70  410000     ADD W2, W0, W0
000D72  E88000     INC2 W0, W0
000D74  884950     MOV W0, 0x92A
339:                       // Phase B //////
340:                       // Present Sin = 0 and loaded next value, DecaySin
341:                       // Polarisation positive
342:               
343:                       OC6RS = PidExec(ADCCSBRight, Sin90[MotorRight.MicStep%MICSTEPS + MotorRight.StepIncLatch], &PidCSBR);
000D76  8048A1     MOV 0x914, W1
000D78  843E80     MOV 0x87D0, W0
000D7A  780100     MOV W0, W2
000D7C  090011     REPEAT #0x11
000D7E  D80082     DIV.SW W1, W2
000D80  FD0080     EXCH W0, W1
000D82  780080     MOV W0, W1
000D84  8048B0     MOV 0x916, W0
000D86  408000     ADD W1, W0, W0
000D88  400080     ADD W0, W0, W1
000D8A  287A20     MOV #0x87A2, W0
000D8C  408000     ADD W1, W0, W0
000D8E  780090     MOV [W0], W1
000D90  8044F0     MOV ADCCSBRight, W0
000D92  208182     MOV #0x818, W2
000D94  07028A     RCALL _PidExec
000D96  880CF0     MOV W0, OC6RS
344:                       MotorRight.Oc51r = OC6RS;
000D98  800CF0     MOV OC6RS, W0
000D9A  8849C0     MOV W0, 0x938
345:                       if((MotorRight.Oc51r + 10) >= PR2)
000D9C  8049C0     MOV 0x938, W0
000D9E  4000EA     ADD W0, #0xA, W1
000DA0  800860     MOV PR2, W0
000DA2  508F80     SUB W1, W0, [W15]
000DA4  390006     BRA NC, 0xDB2
346:                           OC5CONbits.OCM = 0b000;                 // Disable fast deccay
000DA6  800CE0     MOV OC5CON, W0
000DA8  A10000     BCLR W0, #0
000DAA  A11000     BCLR W0, #1
000DAC  A12000     BCLR W0, #2
000DAE  880CE0     MOV W0, OC5CON
000DB0  370005     BRA 0xDBC
347:                       else OC5CONbits.OCM = 0b101;
000DB2  800CE0     MOV OC5CON, W0
000DB4  A00000     BSET W0, #0
000DB6  A11000     BCLR W0, #1
000DB8  A02000     BSET W0, #2
000DBA  880CE0     MOV W0, OC5CON
348:                       MotorRight.Oc51rs = 2 + MotorRight.Oc51r + (PR2 - MotorRight.Oc51r) *  MotorRight.DecaySin / 100;
000DBC  8049C2     MOV 0x938, W2
000DBE  800861     MOV PR2, W1
000DC0  8049C0     MOV 0x938, W0
000DC2  508080     SUB W1, W0, W1
000DC4  804930     MOV 0x926, W0
000DC6  B98800     MUL.SS W1, W0, W0
000DC8  780080     MOV W0, W1
000DCA  200640     MOV #0x64, W0
000DCC  780180     MOV W0, W3
000DCE  090011     REPEAT #0x11
000DD0  D88083     DIV.UW W1, W3
000DD2  410000     ADD W2, W0, W0
000DD4  E88000     INC2 W0, W0
000DD6  884980     MOV W0, 0x930
349:                   }
350:                   MotorRight.StepPresc++;
000DD8  804890     MOV 0x912, W0
000DDA  E80000     INC W0, W0
000DDC  884890     MOV W0, 0x912
351:                   if(MotorRight.StepPresc >= MotorRight.StepPrescValLatch)
000DDE  804891     MOV 0x912, W1
000DE0  8048E0     MOV 0x91C, W0
000DE2  508F80     SUB W1, W0, [W15]
000DE4  350023     BRA LT, 0xE2C
352:                   {
353:                           MotorRight.StepPresc = 0;
000DE6  EF2912     CLR 0x912
354:                           if(MotorRight.Direction == 1)
000DE8  804920     MOV 0x924, W0
000DEA  500FE1     SUB W0, #0x1, [W15]
000DEC  3A000F     BRA NZ, 0xE0C
355:                           {
356:                               MotorRight.MicStep += MotorRight.StepIncLatch;
000DEE  8048A1     MOV 0x914, W1
000DF0  8048B0     MOV 0x916, W0
000DF2  408000     ADD W1, W0, W0
000DF4  8848A0     MOV W0, 0x914
357:                               if(MotorRight.MicStep >= MICSTEPS * 4)
000DF6  8048A1     MOV 0x914, W1
000DF8  843E80     MOV 0x87D0, W0
000DFA  DD0042     SL W0, #2, W0
000DFC  508F80     SUB W1, W0, [W15]
000DFE  350016     BRA LT, 0xE2C
358:                               {
359:                                   MotorRight.MicStep = 0;
000E00  EF2914     CLR 0x914
360:                                   MotorRight.StepIncLatch = MotorRight.StepInc;
000E02  8048C0     MOV 0x918, W0
000E04  8848B0     MOV W0, 0x916
361:                                   MotorRight.StepPrescValLatch = MotorRight.StepPrescVal;
000E06  8048D0     MOV 0x91A, W0
000E08  8848E0     MOV W0, 0x91C
000E0A  370010     BRA 0xE2C
362:                               }
363:                           }
364:                           else
365:                           {
366:                               MotorRight.MicStep -= MotorRight.StepIncLatch;
000E0C  8048A1     MOV 0x914, W1
000E0E  8048B0     MOV 0x916, W0
000E10  508000     SUB W1, W0, W0
000E12  8848A0     MOV W0, 0x914
367:                               if(MotorRight.MicStep < 0)
000E14  8048A0     MOV 0x914, W0
000E16  E00000     CP0 W0
000E18  3D0009     BRA GE, 0xE2C
368:                               {
369:                                   MotorRight.StepIncLatch = MotorRight.StepInc;
000E1A  8048C0     MOV 0x918, W0
000E1C  8848B0     MOV W0, 0x916
370:                                   MotorRight.StepPrescValLatch = MotorRight.StepPrescVal;
000E1E  8048D0     MOV 0x91A, W0
000E20  8848E0     MOV W0, 0x91C
371:                                   MotorRight.MicStep = MICSTEPS * 4 - MotorRight.StepIncLatch;
000E22  843E80     MOV 0x87D0, W0
000E24  DD00C2     SL W0, #2, W1
000E26  8048B0     MOV 0x916, W0
000E28  508000     SUB W1, W0, W0
000E2A  8848A0     MOV W0, 0x914
372:               
373:                               }
374:                           }
375:                   }
376:               }
000E2C  FA8000     ULNK
000E2E  060000     RETURN
377:               //inline void MotorLeftDriver(struct Motor* motor)
378:               //{
379:               //    static unsigned int Oc84rs = 0;
380:               //    static unsigned int Oc73rs = 0;
381:               //    static unsigned int Oc62rs = 0;
382:               //    static unsigned int Oc51rs = 0;
383:               //    static unsigned int Oc84r = 0;
384:               //    static unsigned int Oc73r = 0;
385:               //    static unsigned int Oc62r = 0;
386:               //    static unsigned int Oc51r = 0;
387:               //
388:               //    if(MotorLeft.MicStep/MICSTEPS == 0)			// sin >0, cos >0
389:               //    {
390:               //        // Phase A //////
391:               //        // Present Sin = 0 and loaded next value, DecaySin
392:               //        // Polarisation positive
393:               //        //MST.MicStep = MicStepArray[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
394:               //        if(MotorLeft.Direction)
395:               //        {
396:               //             if(OC4CONbits.OCM != 0b110)
397:               //             OC4CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
398:               //             if(OC3CONbits.OCM != 0b101)
399:               //             OC3CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
400:               //        }
401:               //        else
402:               //        {
403:               //            if(OC2CONbits.OCM != 0b110)
404:               //            OC2CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
405:               //            if(OC1CONbits.OCM != 0b101)
406:               //            OC1CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
407:               //        }
408:               //        OC4RS = Sin90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
409:               //        OC3R = Oc73r;
410:               //        OC3RS = Oc73rs;
411:               //        Oc73r = OC4RS;
412:               //        if((Oc73r + 10) >= PR2)
413:               //            OC3CONbits.OCM = 0b000;                 // Disable fast deccay
414:               //        else OC3CONbits.OCM = 0b101;
415:               //        Oc73rs = 2 + Oc73r + (PR2 - Oc73r) * MotorLeft.DecaySin / 100;
416:               //        // Phase B //////
417:               //        // Present Cos = 1 and loaded next value, DecayCos
418:               //        OC2RS = Cos90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
419:               //        OC1R = Oc51r;
420:               //        OC1RS = Oc51rs;
421:               //        Oc51r = OC2RS;
422:               //        if((Oc51r + 10) >= PR2)
423:               //            OC1CONbits.OCM = 0b000;                 // Disable fast deccay
424:               //        else OC1CONbits.OCM = 0b101;
425:               //        Oc51rs = 2 + Oc51r + (PR2 - Oc51r) * MotorLeft.DecayCos / 100;
426:               //    }
427:               //    else if(MotorLeft.MicStep/MICSTEPS == 1)		// sin >0, cos <0
428:               //    {
429:               //        // Phase A //////
430:               //        // Present Cos = 1 and loaded next value, DecayCos
431:               //        //MST.MicStep = MicStepArray[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
432:               //        if(MotorLeft.Direction)
433:               //        {
434:               //            if(OC2CONbits.OCM != 0b101)
435:               //            OC2CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
436:               //            if(OC1CONbits.OCM != 0b110)
437:               //            OC1CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
438:               //        }
439:               //        else
440:               //        {
441:               //             if(OC4CONbits.OCM != 0b110)
442:               //             OC4CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
443:               //             if(OC3CONbits.OCM != 0b101)
444:               //             OC3CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
445:               //        }
446:               //        OC4RS = Cos90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
447:               //        OC3R = Oc73r;
448:               //        OC3RS = Oc73rs;
449:               //        Oc73r = OC4RS;
450:               //        if((Oc73r + 10) >= PR2)
451:               //            OC3CONbits.OCM = 0b000;                 // Disable fast deccay
452:               //        else OC3CONbits.OCM = 0b101;
453:               //        Oc73rs = 2 + Oc73r + (PR2 - Oc73r) * MotorLeft.DecayCos / 100;
454:               //        // Phase B //////
455:               //        // Present Sin = 0 and loaded next value, DecaySin
456:               //        // Polarisation negative
457:               //
458:               //        OC1RS = Sin90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
459:               //        OC2R = Oc62r;
460:               //        OC2RS = Oc62rs;
461:               //        Oc62r = OC1RS;
462:               //        if((Oc62r + 10) >= PR2)
463:               //            OC2CONbits.OCM = 0b000;                 // Disable fast deccay
464:               //        else OC2CONbits.OCM = 0b101;
465:               //        Oc62rs = 2 + Oc62r + (PR2 - Oc62r) * MotorLeft.DecaySin / 100;
466:               //    }
467:               //    else if(MotorLeft.MicStep/MICSTEPS == 2)		// sin <0, cos <0
468:               //    {
469:               //        // Phase A //////
470:               //        // Present Sin = 0 and loaded next value, DecaySin
471:               //        // Polarisation negative
472:               //        //MST.MicStep = MicStepArray[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
473:               //        if(MotorLeft.Direction)
474:               //        {
475:               //            if(OC3CONbits.OCM != 0b110)
476:               //            OC3CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
477:               //            if(OC4CONbits.OCM != 0b101)
478:               //            OC4CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
479:               //        }
480:               //        else
481:               //        {
482:               //            if(OC2CONbits.OCM != 0b101)
483:               //            OC2CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
484:               //            if(OC1CONbits.OCM != 0b110)
485:               //            OC1CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
486:               //        }
487:               //        OC3RS = Sin90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
488:               //        OC4R = Oc84r;
489:               //        OC4RS = Oc84rs;
490:               //        Oc84r = OC3RS;
491:               //        if((Oc84r + 10) >= PR2)
492:               //            OC4CONbits.OCM = 0b000;                 // Disable fast deccay
493:               //        else OC4CONbits.OCM = 0b101;
494:               //        Oc84rs = 2 + Oc84r + (PR2 - Oc84r) * MotorLeft.DecaySin / 100;
495:               //        // Phase B //////
496:               //        // Present Cos = 1 and loaded next value, DecayCos
497:               //        OC1RS = Cos90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
498:               //        OC2R = Oc62r;
499:               //        OC2RS = Oc62rs;
500:               //        Oc62r = OC1RS;
501:               //        if((Oc62r + 10) >= PR2)
502:               //            OC2CONbits.OCM = 0b000;                 // Disable fast deccay
503:               //        else OC2CONbits.OCM = 0b101;
504:               //        Oc62rs = 2 + Oc62r + (PR2 - Oc62r) * MotorLeft.DecayCos / 100;
505:               //    }
506:               //    else if(MotorLeft.MicStep/MICSTEPS == 3)					// sin <0, cos >0
507:               //    {
508:               //        // Phase A //////
509:               //        // Present Cos = 1 and loaded next value, DecayCos
510:               //        //MST.MicStep = MicStepArray[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
511:               //        if(MotorLeft.Direction)
512:               //        {
513:               //            if(OC2CONbits.OCM != 0b110)
514:               //            OC2CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
515:               //            if(OC1CONbits.OCM != 0b101)
516:               //            OC1CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
517:               //        }
518:               //        else
519:               //        {
520:               //            if(OC3CONbits.OCM != 0b110)
521:               //            OC3CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
522:               //            if(OC4CONbits.OCM != 0b101)
523:               //            OC4CONbits.OCM = 0b101;		// "101" Dual output match mode - continuous
524:               //        }
525:               //        OC3RS = Cos90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
526:               //        OC4R = Oc84r;
527:               //        OC4RS = Oc84rs;
528:               //        Oc84r = OC3RS;
529:               //        if((Oc84r + 10) >= PR2)
530:               //            OC4CONbits.OCM = 0b000;                 // Disable fast deccay
531:               //        else OC4CONbits.OCM = 0b101;
532:               //        Oc84rs = 2 + Oc84r + (PR2 - Oc84r) * MotorLeft.DecayCos / 100;
533:               //        // Phase B //////
534:               //        // Present Sin = 0 and loaded next value, DecaySin
535:               //        // Polarisation positive
536:               //
537:               //        OC2RS = Sin90[MotorLeft.MicStep%MICSTEPS + MotorLeft.StepIncLatch];
538:               //        OC1R = Oc51r;
539:               //        OC1RS = Oc51rs;
540:               //        Oc51r = OC2RS;
541:               //        if((Oc51r + 10) >= PR2)
542:               //            OC1CONbits.OCM = 0b000;                 // Disable fast deccay
543:               //        else OC1CONbits.OCM = 0b101;
544:               //        Oc51rs = 2 + Oc51r + (PR2 - Oc51r) *  MotorLeft.DecaySin / 100;
545:               //    }
546:               //    MotorLeft.StepPresc++;
547:               //    if(MotorLeft.StepPresc >= MotorLeft.StepPrescValLatch)
548:               //    {
549:               //            MotorLeft.StepPresc = 0;
550:               //            if(MotorLeft.Direction == 1)
551:               //            {
552:               //                MotorLeft.MicStep += MotorLeft.StepIncLatch;
553:               //                if(MotorLeft.MicStep >= MICSTEPS * 4)
554:               //                {
555:               //                    MotorLeft.MicStep = 0;
556:               //                    MotorLeft.StepIncLatch = MotorLeft.StepInc;
557:               //                    MotorLeft.StepPrescValLatch = MotorLeft.StepPrescVal;
558:               //                }
559:               //            }
560:               //            else
561:               //            {
562:               //                MotorLeft.MicStep -= MotorLeft.StepIncLatch;
563:               //                if(MotorLeft.MicStep < 0)
564:               //                {
565:               //                    MotorLeft.StepIncLatch = MotorLeft.StepInc;
566:               //                    MotorLeft.StepPrescValLatch = MotorLeft.StepPrescVal;
567:               //                    MotorLeft.MicStep = MICSTEPS * 4 - MotorLeft.StepIncLatch;
568:               //
569:               //                }
570:               //            }
571:               //    }
572:               //}
573:               void MotorInputUpdate(struct Motor* motor)
574:               {
000E30  FA0002     LNK #0x2
000E32  780F00     MOV W0, [W14]
575:                   motor->StepInc = SPEED_CURVE[motor->SpeedAbs][1];
000E34  78001E     MOV [W14], W0
000E36  900060     MOV [W0+12], W0
000E38  B90066     MUL.SU W0, #6, W0
000E3A  780000     MOV W0, W0
000E3C  E88000     INC2 W0, W0
000E3E  780200     MOV W0, W4
000E40  DE804F     ASR W0, #15, W0
000E42  780280     MOV W0, W5
000E44  2019E0     MOV #0x19E, W0
000E46  200001     MOV #0x0, W1
000E48  420000     ADD W4, W0, W0
000E4A  4A8081     ADDC W5, W1, W1
000E4C  8001A4     MOV PSVPAG, W4
000E4E  A4F000     BTSTS.C W0, #15
000E50  D28081     RLC W1, W1
000E52  8801A1     MOV W1, PSVPAG
000E54  780010     MOV [W0], W0
000E56  8801A4     MOV W4, PSVPAG
000E58  780080     MOV W0, W1
000E5A  78001E     MOV [W14], W0
000E5C  980031     MOV W1, [W0+6]
576:                   motor->StepPrescVal = SPEED_CURVE[motor->SpeedAbs][2];
000E5E  78001E     MOV [W14], W0
000E60  900060     MOV [W0+12], W0
000E62  B90066     MUL.SU W0, #6, W0
000E64  780000     MOV W0, W0
000E66  400064     ADD W0, #0x4, W0
000E68  780100     MOV W0, W2
000E6A  DE804F     ASR W0, #15, W0
000E6C  780180     MOV W0, W3
000E6E  2019E0     MOV #0x19E, W0
000E70  200001     MOV #0x0, W1
000E72  410000     ADD W2, W0, W0
000E74  498081     ADDC W3, W1, W1
000E76  8001A2     MOV PSVPAG, W2
000E78  A4F000     BTSTS.C W0, #15
000E7A  D28081     RLC W1, W1
000E7C  8801A1     MOV W1, PSVPAG
000E7E  780010     MOV [W0], W0
000E80  8801A2     MOV W2, PSVPAG
000E82  780080     MOV W0, W1
000E84  78001E     MOV [W14], W0
000E86  980041     MOV W1, [W0+8]
577:               
578:                   SpeedSlewRate(motor);
000E88  78001E     MOV [W14], W0
000E8A  07FCA4     RCALL SpeedSlewRate
579:                   
580:                   if(motor->Speed > 0)
000E8C  78001E     MOV [W14], W0
000E8E  900070     MOV [W0+14], W0
000E90  E00000     CP0 W0
000E92  340017     BRA LE, 0xEC2
581:                   {
582:                       if(motor->SpeedAbs == 0)
000E94  78001E     MOV [W14], W0
000E96  900060     MOV [W0+12], W0
000E98  E00000     CP0 W0
000E9A  3A000B     BRA NZ, 0xEB2
583:                       {
584:                           motor->StepIncLatch = SPEED_CURVE[1][1];
000E9C  201A60     MOV #0x1A6, W0
000E9E  200001     MOV #0x0, W1
000EA0  8001A2     MOV PSVPAG, W2
000EA2  A4F000     BTSTS.C W0, #15
000EA4  D28081     RLC W1, W1
000EA6  8801A1     MOV W1, PSVPAG
000EA8  780010     MOV [W0], W0
000EAA  8801A2     MOV W2, PSVPAG
000EAC  780080     MOV W0, W1
000EAE  78001E     MOV [W14], W0
000EB0  980021     MOV W1, [W0+4]
585:                       }
586:                       motor->SpeedAbs = motor->Speed;
000EB2  78001E     MOV [W14], W0
000EB4  9000F0     MOV [W0+14], W1
000EB6  78001E     MOV [W14], W0
000EB8  980061     MOV W1, [W0+12]
587:                       motor->Direction = 1;
000EBA  78001E     MOV [W14], W0
000EBC  200011     MOV #0x1, W1
000EBE  980811     MOV W1, [W0+18]
000EC0  370022     BRA 0xF06
588:               
589:                   }
590:                   else if(motor->Speed < 0)
000EC2  78001E     MOV [W14], W0
000EC4  900070     MOV [W0+14], W0
000EC6  E00000     CP0 W0
000EC8  3D0018     BRA GE, 0xEFA
591:                   {
592:                       if(motor->SpeedAbs == 0)
000ECA  78001E     MOV [W14], W0
000ECC  900060     MOV [W0+12], W0
000ECE  E00000     CP0 W0
000ED0  3A000B     BRA NZ, 0xEE8
593:                       {
594:                           motor->StepIncLatch = SPEED_CURVE[1][1];
000ED2  201A60     MOV #0x1A6, W0
000ED4  200001     MOV #0x0, W1
000ED6  8001A2     MOV PSVPAG, W2
000ED8  A4F000     BTSTS.C W0, #15
000EDA  D28081     RLC W1, W1
000EDC  8801A1     MOV W1, PSVPAG
000EDE  780010     MOV [W0], W0
000EE0  8801A2     MOV W2, PSVPAG
000EE2  780080     MOV W0, W1
000EE4  78001E     MOV [W14], W0
000EE6  980021     MOV W1, [W0+4]
595:                       }
596:                       motor->SpeedAbs = -(motor->Speed);
000EE8  78001E     MOV [W14], W0
000EEA  900070     MOV [W0+14], W0
000EEC  EA0080     NEG W0, W1
000EEE  78001E     MOV [W14], W0
000EF0  980061     MOV W1, [W0+12]
597:                       motor->Direction = 0;
000EF2  78001E     MOV [W14], W0
000EF4  EB0080     CLR W1
000EF6  980811     MOV W1, [W0+18]
000EF8  370006     BRA 0xF06
598:                    }
599:                    else
600:                    {
601:                       motor->SpeedAbs = 0;
000EFA  78001E     MOV [W14], W0
000EFC  EB0080     CLR W1
000EFE  980061     MOV W1, [W0+12]
602:                       motor->StepIncLatch = 0;
000F00  78001E     MOV [W14], W0
000F02  EB0080     CLR W1
000F04  980021     MOV W1, [W0+4]
603:                    }
604:               }
000F06  FA8000     ULNK
000F08  060000     RETURN
605:               void MotorsInputUpdate(void)
606:               {
000F0A  FA0000     LNK #0x0
607:                   MotorInputUpdate(&MotorRight);
000F0C  209120     MOV #0x912, W0
000F0E  07FF90     RCALL MotorInputUpdate
608:                   MotorInputUpdate(&MotorLeft);
000F10  208EA0     MOV #0x8EA, W0
000F12  07FF8E     RCALL MotorInputUpdate
609:               }
000F14  FA8000     ULNK
000F16  060000     RETURN
610:               void MotorsInit(void)
611:               {
000F18  FA0000     LNK #0x0
612:                   //////////////// MicStepArray Init  /////////////////////////////////////////////////////////////////////////
613:               //	int i;
614:               //	for(i = 0; i <= MICSTEPS; i++)
615:               //	{
616:               //		Sin90[i] = (unsigned int)((float)T2_PR2 * sin((float)i/(float)(MICSTEPS) * (PI/2)));
617:               //		Cos90[i] = (unsigned int)((float)T2_PR2 * cos((float)i/(float)(MICSTEPS) * (PI/2)));
618:               //	}
619:                   //////////////////////////////////////////////////////////////////////////////////////////////////////
620:               	/////////////// Motor Control Pins ///////////////////////////////////////////////////////////////////////////////
621:               	/////////////// Motor Right ///////////////////
622:                       //  ENA -   RF1
623:                       //  In1 -   OC8/CN16/RD7
624:                       //  In2 -   OC7/CN15/RD6
625:                       //  ENB -   RF0
626:                       //  In3 -   OC6/CN14/RD5
627:                       //  In4 -   OC5/CN13/RD4
628:                       /////////////// Motor Left ///////////////////
629:                       //  ENA -   RD13
630:                       //  In1 -   OC4/RD3
631:                       //  In2 -   OC3/RD2
632:                       //  ENB -   RD12
633:                       //  In3 -   EMUD2/OC2/RD1
634:                       //  In4 -   EMUC2/OC1/RD0
635:                       ///////////////////////////////////////////////
636:               
637:                   TRISFbits.TRISF1 = 0;		// Enable Motor driver pins as outputs
000F1A  A922DE     BCLR TRISF, #1
638:               	TRISFbits.TRISF0 = 0;		//
000F1C  A902DE     BCLR TRISF, #0
639:               	TRISDbits.TRISD13 = 0;		//
000F1E  A9A2D3     BCLR 0x2D3, #5
640:               	TRISDbits.TRISD12 = 0;		//
000F20  A982D3     BCLR 0x2D3, #4
641:               
642:                       PORTFbits.RF1 = 1;              // Enable Motor drivers
000F22  A822E0     BSET PORTF, #1
643:                      // PORTFbits.RF0 = 1;              //
644:                       PORTF |= 3;
000F24  801700     MOV PORTF, W0
000F26  B30030     IOR #0x3, W0
000F28  881700     MOV W0, PORTF
645:                       PORTDbits.RD13 = 1;             //
000F2A  A8A2D5     BSET 0x2D5, #5
646:                       PORTDbits.RD12 = 1;             //
000F2C  A882D5     BSET 0x2D5, #4
647:               
648:                       TRISDbits.TRISD7 = 0;		// Enable Motor driver pins as outputs
000F2E  A9E2D2     BCLR TRISD, #7
649:               	TRISDbits.TRISD6 = 0;		//
000F30  A9C2D2     BCLR TRISD, #6
650:               	TRISDbits.TRISD5 = 0;		//
000F32  A9A2D2     BCLR TRISD, #5
651:               	TRISDbits.TRISD4 = 0;		//
000F34  A982D2     BCLR TRISD, #4
652:                       TRISDbits.TRISD3 = 0;		// Enable Motor driver pins as outputs
000F36  A962D2     BCLR TRISD, #3
653:               	TRISDbits.TRISD2 = 0;		//
000F38  A942D2     BCLR TRISD, #2
654:               	TRISDbits.TRISD1 = 0;		//
000F3A  A922D2     BCLR TRISD, #1
655:               	TRISDbits.TRISD0 = 0;		//
000F3C  A902D2     BCLR TRISD, #0
656:               
657:                       PORTDbits.RD7 = 0;              // Enable Motor drivers
000F3E  A9E2D4     BCLR PORTD, #7
658:                       PORTDbits.RD6 = 0;              //
000F40  A9C2D4     BCLR PORTD, #6
659:                       PORTDbits.RD5 = 0;              //
000F42  A9A2D4     BCLR PORTD, #5
660:                       PORTDbits.RD4 = 0;              //
000F44  A982D4     BCLR PORTD, #4
661:                       PORTDbits.RD3 = 0;              // Enable Motor drivers
000F46  A962D4     BCLR PORTD, #3
662:                       PORTDbits.RD2 = 0;              //
000F48  A942D4     BCLR PORTD, #2
663:                       PORTDbits.RD1 = 0;              //
000F4A  A922D4     BCLR PORTD, #1
664:                       PORTDbits.RD0 = 0;              //
000F4C  A902D4     BCLR PORTD, #0
665:               	/////////////// Output Compare 8  Setup  ////////////////////////////////////////////////////////////////////
666:               	OC8CON = 0;			// Turn off Output Compare Module
000F4E  EF21AE     CLR OC8CON
667:               	OC8RS = 0;			// Write duty cycle buffer register
000F50  EF21AA     CLR OC8RS
668:               	OC8R = 0;			// Write OCR to initial duty cycle value
000F52  EF21AC     CLR OC8R
669:               	OC8CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000F54  800D70     MOV OC8CON, W0
000F56  A10000     BCLR W0, #0
000F58  A01000     BSET W0, #1
000F5A  A02000     BSET W0, #2
000F5C  880D70     MOV W0, OC8CON
670:               					// "111" Set OC mode to Simple PMW with Fault input
671:               	OC8CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000F5E  A961AE     BCLR OC8CON, #3
672:                                                       // "1" Timer 3 as time base
673:               	/////////////// Output Compare 7  Setup  ////////////////////////////////////////////////////////////////////
674:               	OC7CON = 0;			// Turn off Output Compare Module
000F60  EF21A8     CLR OC7CON
675:               	OC7RS = 0;			// Write duty cycle buffer register
000F62  EF21A4     CLR OC7RS
676:               	OC7R = 0xFFFF;			// Write OCR to initial duty cycle value
000F64  EB8000     SETM W0
000F66  880D30     MOV W0, OC7R
677:               	OC7CONbits.OCM = 0b101;		// Dual output match mode - continuous
000F68  800D40     MOV OC7CON, W0
000F6A  A00000     BSET W0, #0
000F6C  A11000     BCLR W0, #1
000F6E  A02000     BSET W0, #2
000F70  880D40     MOV W0, OC7CON
678:                                                           // "110" Set OC mode to Simple PMW without Fault input
679:                                                           // "111" Set OC mode to Simple PMW with Fault input
680:               	OC7CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000F72  A961A8     BCLR OC7CON, #3
681:                                                           // "1" Timer 3 as time base
682:                       /////////////// Output Compare 6  Setup  ////////////////////////////////////////////////////////////////////
683:               	OC6CON = 0;			// Turn off Output Compare Module
000F74  EF21A2     CLR OC6CON
684:               	OC6RS = 0;			// Write duty cycle buffer register
000F76  EF219E     CLR OC6RS
685:               	OC6R = 0;			// Write OC2R to initial duty cycle value
000F78  EF21A0     CLR OC6R
686:               	OC6CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000F7A  800D10     MOV OC6CON, W0
000F7C  A10000     BCLR W0, #0
000F7E  A01000     BSET W0, #1
000F80  A02000     BSET W0, #2
000F82  880D10     MOV W0, OC6CON
687:                                                           // "111" Set OC mode to Simple PMW with Fault input
688:               	OC6CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000F84  A961A2     BCLR OC6CON, #3
689:                                                           // "1" Timer 3 as time base
690:                       /////////////// Output Compare 5  Setup  ////////////////////////////////////////////////////////////////////
691:               	OC5CON = 0;			// Turn off Output Compare Module
000F86  EF219C     CLR OC5CON
692:               	OC5RS = 0;			// Write duty cycle buffer register
000F88  EF2198     CLR OC5RS
693:               	OC5R = 0xFFFF;			// Write OC2R to initial duty cycle value
000F8A  EB8000     SETM W0
000F8C  880CD0     MOV W0, OC5R
694:               	OC5CONbits.OCM = 0b101;		// Dual output match mode - continuous
000F8E  800CE0     MOV OC5CON, W0
000F90  A00000     BSET W0, #0
000F92  A11000     BCLR W0, #1
000F94  A02000     BSET W0, #2
000F96  880CE0     MOV W0, OC5CON
695:                                                           // "110" Set OC mode to Simple PMW without Fault input
696:                                                           // "111" Set OC mode to Simple PMW with Fault input
697:               	OC5CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000F98  A9619C     BCLR OC5CON, #3
698:                                                           // "1" Timer 3 as time base
699:                       /////////////// Output Compare 4  Setup  ////////////////////////////////////////////////////////////////////
700:               	OC4CON = 0;			// Turn off Output Compare Module
000F9A  EF2196     CLR OC4CON
701:               	OC4RS = 0;			// Write duty cycle buffer register
000F9C  EF2192     CLR OC4RS
702:               	OC4R = 0;			// Write OC2R to initial duty cycle value
000F9E  EF2194     CLR OC4R
703:               	OC4CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000FA0  800CB0     MOV OC4CON, W0
000FA2  A10000     BCLR W0, #0
000FA4  A01000     BSET W0, #1
000FA6  A02000     BSET W0, #2
000FA8  880CB0     MOV W0, OC4CON
704:                                                           // "111" Set OC mode to Simple PMW with Fault input
705:               	OC4CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000FAA  A96196     BCLR OC4CON, #3
706:                                                           // "1" Timer 3 as time base
707:                       /////////////// Output Compare 3  Setup  ////////////////////////////////////////////////////////////////////
708:               	OC3CON = 0;			// Turn off Output Compare Module
000FAC  EF2190     CLR OC3CON
709:               	OC3RS = 0;			// Write duty cycle buffer register
000FAE  EF218C     CLR OC3RS
710:               	OC3R = 0;			// Write OC2R to initial duty cycle value
000FB0  EF218E     CLR OC3R
711:               	OC3CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000FB2  800C80     MOV OC3CON, W0
000FB4  A10000     BCLR W0, #0
000FB6  A01000     BSET W0, #1
000FB8  A02000     BSET W0, #2
000FBA  880C80     MOV W0, OC3CON
712:                                                           // "111" Set OC mode to Simple PMW with Fault input
713:               	OC3CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000FBC  A96190     BCLR OC3CON, #3
714:                                                           // "1" Timer 3 as time base
715:                       /////////////// Output Compare 2  Setup  ////////////////////////////////////////////////////////////////////
716:               	OC2CON = 0;			// Turn off Output Compare Module
000FBE  EF218A     CLR OC2CON
717:               	OC2RS = 0;			// Write duty cycle buffer register
000FC0  EF2186     CLR OC2RS
718:               	OC2R = 0;			// Write OC2R to initial duty cycle value
000FC2  EF2188     CLR OC2R
719:               	OC2CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000FC4  800C50     MOV OC2CON, W0
000FC6  A10000     BCLR W0, #0
000FC8  A01000     BSET W0, #1
000FCA  A02000     BSET W0, #2
000FCC  880C50     MOV W0, OC2CON
720:                                                           // "111" Set OC mode to Simple PMW with Fault input
721:               	OC2CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000FCE  A9618A     BCLR OC2CON, #3
722:                                                           // "1" Timer 3 as time base
723:                       /////////////// Output Compare 1  Setup  ////////////////////////////////////////////////////////////////////
724:               	OC1CON = 0;			// Turn off Output Compare Module
000FD0  EF2184     CLR OC1CON
725:               	OC1RS = 1;			// Write duty cycle buffer register
000FD2  200010     MOV #0x1, W0
000FD4  880C00     MOV W0, OC1RS
726:               	OC1R = 0;			// Write OC2R to initial duty cycle value
000FD6  EF2182     CLR OC1R
727:               	OC1CONbits.OCM = 0b110;		// "110" Set OC mode to Simple PMW without Fault input
000FD8  800C20     MOV OC1CON, W0
000FDA  A10000     BCLR W0, #0
000FDC  A01000     BSET W0, #1
000FDE  A02000     BSET W0, #2
000FE0  880C20     MOV W0, OC1CON
728:                                                           // "111" Set OC mode to Simple PMW with Fault input
729:               	OC1CONbits.OCTSEL = 0;		// "0" Timer 2 as time base
000FE2  A96184     BCLR OC1CON, #3
730:                                                           // "1" Timer 3 as time base
731:               	//////////// Timer 2  Setup  ////////////////////////////////////////////////////////////////////////////////
732:               	T2CON = 0;			// Stops the Timer2 and reset control register
000FE4  EF2110     CLR T2CON
733:               	TMR2 = 0;			// Clear contents of the timer register
000FE6  EF2106     CLR TMR2
734:               	T2CONbits.TCKPS = T2_TCKPS;	// Timer Input Clock Prescale Select bits
000FE8  800880     MOV T2CON, W0
000FEA  A14000     BCLR W0, #4
000FEC  A15000     BCLR W0, #5
000FEE  880880     MOV W0, T2CON
735:                                                           // 11 = 1:256 prescale value
736:                                                           // 10 = 1:64 prescale value
737:                                                           // 01 = 1:8 prescale value
738:                                                           // 00 = 1:1 prescale value
739:               	PR2 = T2_PR2;			// Load the Period register
000FF0  205C20     MOV #0x5C2, W0
000FF2  880860     MOV W0, PR2
740:               	IPC1bits.T2IP = 0x3;		// Set Timer2 interrupt priority to 3 (1-lowest, 7-highiest)
000FF4  8004B0     MOV IPC1, W0
000FF6  A08000     BSET W0, #8
000FF8  A09000     BSET W0, #9
000FFA  A1A000     BCLR W0, #10
000FFC  8804B0     MOV W0, IPC1
741:               	IFS0bits.T2IF = 0;		// Clear the Timer2 interrupt status flag
000FFE  A9C084     BCLR IFS0, #6
742:               	IEC0bits.T2IE = 1;		// Enable Timer2 interrupts
001000  A8C08C     BSET IEC0, #6
743:               	T2CONbits.TON = 1;		// Start Timer2
001002  A8E111     BSET 0x111, #7
744:               
745:                       //motor->StepInc = MCurve[motor->SpeedAbs][1];
746:                       //motor->PrescVal = MCurve[motor->SpeedAbs][2];
747:               }
001004  FA8000     ULNK
001006  060000     RETURN
748:               
749:               ///////// Timer2 Interrupt routine //////////////////////
750:               void __attribute__((__interrupt__,no_auto_psv)) _T2Interrupt(void)
751:               {
001008  F80036     PUSH RCOUNT
00100A  BE9F80     MOV.D W0, [W15++]
00100C  BE9F82     MOV.D W2, [W15++]
00100E  BE9F84     MOV.D W4, [W15++]
001010  BE9F86     MOV.D W6, [W15++]
001012  FA0000     LNK #0x0
752:               	IFS0bits.T2IF = 0;				// Clear Timer2 interrupt status flag
001014  A9C084     BCLR IFS0, #6
753:                       ADCon1_m = ADCON1;
001016  801500     MOV ADCON1, W0
001018  884A60     MOV W0, ADCon1_m
754:                       MotorDecayLoad();                               // Load decay timers for motor drivers
00101A  07FC91     RCALL MotorDecayLoad
755:                       //MotorRightDecayLoad();
756:                       //MotorRightDecayLoad();
757:                       ADCUpdate();                                    // Update anologue values
00101C  070092     RCALL ADCUpdate
758:                       MotorRightDriver();
00101E  07FC94     RCALL MotorRightDriver
759:                       MotorRightDriver();
001020  07FC93     RCALL MotorRightDriver
760:                       MotorsInputUpdate();
001022  07FF73     RCALL MotorsInputUpdate
761:                       
762:                       Tick();
001024  07FC97     RCALL 0x954
763:               
764:                       if(debug == 1)
001026  804A50     MOV debug, W0
001028  500FE1     SUB W0, #0x1, [W15]
00102A  3A0001     BRA NZ, 0x102E
765:                       {
766:                           temp = 0;
00102C  EF294E     CLR temp
767:               
768:                       }
769:                       if(debug == 2)
00102E  804A50     MOV debug, W0
001030  500FE2     SUB W0, #0x2, [W15]
001032  3A0001     BRA NZ, 0x1036
770:                       {
771:                           temp = 0;
001034  EF294E     CLR temp
772:               
773:                       }
774:                       if(debug == 3)
001036  804A50     MOV debug, W0
001038  500FE3     SUB W0, #0x3, [W15]
00103A  3A0001     BRA NZ, 0x103E
775:                       {
776:                           temp = 0;
00103C  EF294E     CLR temp
777:               
778:                       }
779:                       if(debug == 4)
00103E  804A50     MOV debug, W0
001040  500FE4     SUB W0, #0x4, [W15]
001042  3A0001     BRA NZ, 0x1046
780:                       {
781:                           temp = 0;
001044  EF294E     CLR temp
782:               
783:                       }
784:                       if(debug == 5)
001046  804A50     MOV debug, W0
001048  500FE5     SUB W0, #0x5, [W15]
00104A  3A0001     BRA NZ, 0x104E
785:                       {
786:                           temp = 0;
00104C  EF294E     CLR temp
787:                           
788:                       }
789:                       if(debug == 6)
00104E  804A50     MOV debug, W0
001050  500FE6     SUB W0, #0x6, [W15]
001052  3A0001     BRA NZ, 0x1056
790:                       {
791:                           debug = 0;
001054  EF294A     CLR debug
792:               
793:                       }
794:                       debug++;
001056  804A50     MOV debug, W0
001058  E80000     INC W0, W0
00105A  884A50     MOV W0, debug
795:               
796:                       
797:               //        Present++;
798:               //        if(Present == 800)
799:               //        {
800:               //            Present = 0;
801:               //            if(Speed == 250)
802:               //                SpeedChange = -1;
803:               //            if(Speed == -250)
804:               //                SpeedChange = 1;
805:               //            Speed += SpeedChange;
806:               //        }
807:               //        Tick = 1;
808:               
809:               }
00105C  FA8000     ULNK
00105E  BE034F     MOV.D [--W15], W6
001060  BE024F     MOV.D [--W15], W4
001062  BE014F     MOV.D [--W15], W2
001064  BE004F     MOV.D [--W15], W0
001066  F90036     POP RCOUNT
001068  064000     RETFIE
810:               
811:               //void MotorAcc(int dir,int rate, int inc )
812:               //{
813:               //    Direction = dir;
814:               //    while(1)
815:               //    {
816:               //        while(Tick == 0);
817:               //        Tick = 0;
818:               //        Rev = Rev + inc;
819:               //        if(Rev > rate)
820:               //        {
821:               //          Rev = rate;
822:               //          break;
823:               //        }
824:               //        if(Rev < 0)
825:               //        {
826:               //           Rev = 0;
827:               //          break;
828:               //        }
829:               //    }
830:               //
831:               //}
---  C:/Marcin Dec/private/Segway/Segway 19.07.15.X/ADC.c  ----------------------------------------------
1:                 /**********************************************************************c
2:                  * Author: Marcin Dec
3:                  * Date: 11.08.2015
4:                  * FileName:        ADC.c
5:                  * Dependencies:    ADC.h
6:                  * Processor:       dsPIC30F6013A
7:                  * Compiler:        MPLAB® XC16 C Compiler
8:                  *
9:                  ************************************************************************/
10:                #include <p30f6013A.h>
11:                /////////////// Motor Right ///////////////////
12:                //  CSA - AN8/RB8
13:                //  CSB - AN9/RB9
14:                /////////////// Motor Left ///////////////////
15:                //  CSA - AN6/OCFA/RB6
16:                //  CSB - AN7/RB7
17:                /////////////// Battery //////////////////////
18:                // Current - AN10/RB10
19:                // Voltage - AN11/RB11
20:                
21:                #define ADC_BUFF_LENGTH 5
22:                #define ADC_INPUTS  6
23:                int* ADC16Ptr;
24:                int ADCBuff[ADC_BUFF_LENGTH];
25:                const int ADCInputs[ADC_INPUTS] = {8, 9, 6, 7, 10, 11};
26:                int ADCCSARight;
27:                int ADCCSBRight;
28:                int ADCCSALeft;
29:                int ADCCSBLeft;
30:                int ADCCurrent;
31:                int ADCVoltage;
32:                int ADCCSARightArr[ADC_BUFF_LENGTH];
33:                int ADCCSBRightArr[ADC_BUFF_LENGTH];
34:                int ADCCSALeftArr[ADC_BUFF_LENGTH];
35:                int ADCCSBLeftArr[ADC_BUFF_LENGTH];
36:                int ADCCurrentArr[ADC_BUFF_LENGTH];
37:                int ADCVoltageArr[ADC_BUFF_LENGTH];
38:                int ADCon1;
39:                int ADCon1_2;
40:                void ADCBuffLoad(int* buff) {
00106A  FA0004     LNK #0x4
00106C  980710     MOV W0, [W14+2]
41:                    int i;
42:                    for (i = 0; i < 6; i++) {
00106E  EB0000     CLR W0
001070  780F00     MOV W0, [W14]
001072  37000B     BRA 0x108A
001088  E80F1E     INC [W14], [W14]
00108A  78001E     MOV [W14], W0
00108C  500FE5     SUB W0, #0x5, [W15]
00108E  34FFF2     BRA LE, 0x1074
43:                        *(buff + i) = *(ADC16Ptr + i);
001074  78001E     MOV [W14], W0
001076  400000     ADD W0, W0, W0
001078  90009E     MOV [W14+2], W1
00107A  408080     ADD W1, W0, W1
00107C  804482     MOV ADC16Ptr, W2
00107E  78001E     MOV [W14], W0
001080  400000     ADD W0, W0, W0
001082  410000     ADD W2, W0, W0
001084  780010     MOV [W0], W0
001086  780880     MOV W0, [W1]
44:                    }
45:                }
001090  FA8000     ULNK
001092  060000     RETURN
46:                void ADCBuffCopy(int* buff, int* copy) {
001094  FA0006     LNK #0x6
001096  980710     MOV W0, [W14+2]
001098  980721     MOV W1, [W14+4]
47:                    int i;
48:                    for (i = 0; i < 6; i++) {
00109A  EB0000     CLR W0
00109C  780F00     MOV W0, [W14]
00109E  37000B     BRA 0x10B6
0010B4  E80F1E     INC [W14], [W14]
0010B6  78001E     MOV [W14], W0
0010B8  500FE5     SUB W0, #0x5, [W15]
0010BA  34FFF2     BRA LE, 0x10A0
49:                        *(copy + i) = *(buff + i);
0010A0  78001E     MOV [W14], W0
0010A2  400000     ADD W0, W0, W0
0010A4  9000AE     MOV [W14+4], W1
0010A6  408080     ADD W1, W0, W1
0010A8  78001E     MOV [W14], W0
0010AA  400000     ADD W0, W0, W0
0010AC  90011E     MOV [W14+2], W2
0010AE  410000     ADD W2, W0, W0
0010B0  780010     MOV [W0], W0
0010B2  780880     MOV W0, [W1]
50:                    }
51:                }
0010BC  FA8000     ULNK
0010BE  060000     RETURN
52:                int ADCMax(int* buff) {
0010C0  FA0006     LNK #0x6
0010C2  980720     MOV W0, [W14+4]
53:                    int max = 0, i;
0010C4  EB0000     CLR W0
0010C6  780F00     MOV W0, [W14]
54:                    for (i = 0; i < ADC_BUFF_LENGTH; i++) {
0010C8  EB0000     CLR W0
0010CA  980710     MOV W0, [W14+2]
0010CC  370010     BRA 0x10EE
0010E8  90001E     MOV [W14+2], W0
0010EA  E80000     INC W0, W0
0010EC  980710     MOV W0, [W14+2]
0010EE  90001E     MOV [W14+2], W0
0010F0  500FE4     SUB W0, #0x4, [W15]
0010F2  34FFED     BRA LE, 0x10CE
55:                        if (*buff > max) {
0010CE  90002E     MOV [W14+4], W0
0010D0  780010     MOV [W0], W0
0010D2  500F9E     SUB W0, [W14], [W15]
0010D4  340006     BRA LE, 0x10E2
56:                            max = *buff++;
0010D6  90002E     MOV [W14+4], W0
0010D8  780F10     MOV [W0], [W14]
0010DA  90002E     MOV [W14+4], W0
0010DC  E88000     INC2 W0, W0
0010DE  980720     MOV W0, [W14+4]
0010E0  370003     BRA 0x10E8
57:                        } else buff++;
0010E2  90002E     MOV [W14+4], W0
0010E4  E88000     INC2 W0, W0
0010E6  980720     MOV W0, [W14+4]
58:                    }
59:                    return max;
0010F4  78001E     MOV [W14], W0
60:                }
0010F6  FA8000     ULNK
0010F8  060000     RETURN
61:                
62:                int ADCMean(int* buff) {
0010FA  FA0006     LNK #0x6
0010FC  980720     MOV W0, [W14+4]
63:                    int mean = 0, i;
0010FE  EB0000     CLR W0
001100  780F00     MOV W0, [W14]
64:                    for (i = 0; i < ADC_BUFF_LENGTH; i++) {
001102  EB0000     CLR W0
001104  980710     MOV W0, [W14+2]
001106  370009     BRA 0x111A
001114  90001E     MOV [W14+2], W0
001116  E80000     INC W0, W0
001118  980710     MOV W0, [W14+2]
00111A  90001E     MOV [W14+2], W0
00111C  500FE4     SUB W0, #0x4, [W15]
00111E  34FFF4     BRA LE, 0x1108
65:                        mean += *buff++;
001108  90002E     MOV [W14+4], W0
00110A  780010     MOV [W0], W0
00110C  400F1E     ADD W0, [W14], [W14]
00110E  90002E     MOV [W14+4], W0
001110  E88000     INC2 W0, W0
001112  980720     MOV W0, [W14+4]
66:                    }
67:                    mean >>= 2;
001120  78001E     MOV [W14], W0
001122  DE8042     ASR W0, #2, W0
001124  780F00     MOV W0, [W14]
68:                    return mean;
001126  78001E     MOV [W14], W0
69:                }
001128  FA8000     ULNK
00112A  060000     RETURN
70:                
71:                int ADCInpChange(void) {
00112C  FA0000     LNK #0x0
72:                    static int index = -1;
73:                    index++;
00112E  804A90     MOV 0x952, W0
001130  E80000     INC W0, W0
001132  884A90     MOV W0, 0x952
74:                    if (index >= ADC_INPUTS)
001134  804A90     MOV 0x952, W0
001136  500FE5     SUB W0, #0x5, [W15]
001138  340001     BRA LE, 0x113C
75:                        index = 0;
00113A  EF2952     CLR 0x952
76:                    //ADCHS = (ADCHS & 0xFFF0) | ADCInputs[index];
77:                    return index;
00113C  804A90     MOV 0x952, W0
78:                }
00113E  FA8000     ULNK
001140  060000     RETURN
79:                
80:                void ADCUpdate(void) {
001142  FA0002     LNK #0x2
81:                    static int index = -1;
82:                    int index_new;
83:                    ADCon1_2 = ADCON1;
001144  801500     MOV ADCON1, W0
001146  884730     MOV W0, ADCon1_2
84:                    ADCON1bits.ASAM = 0; // stop auto sampling
001148  A942A0     BCLR ADCON1, #2
85:                    ADCon1 = ADCON1;
00114A  801500     MOV ADCON1, W0
00114C  884720     MOV W0, ADCon1
86:                    //ADCON1bits.SAMP = 0; // stop sampling if in progress
87:                    ADCBuffLoad(ADCBuff); // retain ADCBUF content
00114E  208920     MOV #0x892, W0
001150  07FF8C     RCALL ADCBuffLoad
88:                    index_new = ADCInpChange(); // switch channel and return its index
001152  07FFEC     RCALL ADCInpChange
001154  780F00     MOV W0, [W14]
89:                    //IFS0bits.ADIF = 0;
90:                    ADCON1bits.ASAM = 1; // start next sampling cycle
001156  A842A0     BSET ADCON1, #2
91:                    switch (index) {
001158  804A80     MOV 0x950, W0
00115A  500FE2     SUB W0, #0x2, [W15]
00115C  320016     BRA Z, 0x118A
00115E  500FE2     SUB W0, #0x2, [W15]
001160  3C0005     BRA GT, 0x116C
001162  E00000     CP0 W0
001164  32000A     BRA Z, 0x117A
001166  500FE1     SUB W0, #0x1, [W15]
001168  32000C     BRA Z, 0x1182
00116A  37001F     BRA 0x11AA
00116C  500FE4     SUB W0, #0x4, [W15]
00116E  320015     BRA Z, 0x119A
001170  500FE4     SUB W0, #0x4, [W15]
001172  35000F     BRA LT, 0x1192
001174  500FE5     SUB W0, #0x5, [W15]
001176  320015     BRA Z, 0x11A2
001178  370018     BRA 0x11AA
92:                        case 0:
93:                            ADCBuffCopy(ADCBuff, ADCCSARightArr);
00117A  208A81     MOV #0x8A8, W1
00117C  208920     MOV #0x892, W0
00117E  07FF8A     RCALL ADCBuffCopy
94:                            //ADCCSARight = ADCMax(ADCBuff);
95:                            break;
001180  370014     BRA 0x11AA
96:                        case 1:
97:                            ADCBuffCopy(ADCBuff, ADCCSBRightArr);
001182  208B21     MOV #0x8B2, W1
001184  208920     MOV #0x892, W0
001186  07FF86     RCALL ADCBuffCopy
98:                            //ADCCSBRight = ADCMax(ADCBuff);
99:                            break;
001188  370010     BRA 0x11AA
100:                       case 2:
101:                           ADCBuffCopy(ADCBuff, ADCCSALeftArr);
00118A  208BC1     MOV #0x8BC, W1
00118C  208920     MOV #0x892, W0
00118E  07FF82     RCALL ADCBuffCopy
102:                           //ADCCSALeft = ADCMax(ADCBuff);
103:                           break;
001190  37000C     BRA 0x11AA
104:                       case 3:
105:                           ADCBuffCopy(ADCBuff, ADCCSBLeftArr);
001192  208C61     MOV #0x8C6, W1
001194  208920     MOV #0x892, W0
001196  07FF7E     RCALL ADCBuffCopy
106:                           //ADCCSBLeft = ADCMax(ADCBuff);
107:                           break;
001198  370008     BRA 0x11AA
108:                       case 4:
109:                           ADCBuffCopy(ADCBuff, ADCCurrentArr);
00119A  208D01     MOV #0x8D0, W1
00119C  208920     MOV #0x892, W0
00119E  07FF7A     RCALL ADCBuffCopy
110:                           //ADCCurrent = ADCMean(ADCBuff);
111:                           break;
0011A0  370004     BRA 0x11AA
112:                       case 5:
113:                           ADCBuffCopy(ADCBuff, ADCVoltageArr);
0011A2  208DA1     MOV #0x8DA, W1
0011A4  208920     MOV #0x892, W0
0011A6  07FF76     RCALL ADCBuffCopy
114:                           //ADCVoltage = ADCMean(ADCBuff);
115:                           break;
0011A8  000000     NOP
116:                   }
117:                   index = index_new; // retain index for next cycle
0011AA  78009E     MOV [W14], W1
0011AC  884A81     MOV W1, 0x950
118:               }
0011AE  FA8000     ULNK
0011B0  060000     RETURN
119:               
120:               void ADCInit(void) {
0011B2  FA0000     LNK #0x0
121:                   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
122:                   /* bit 15-0 PCFG<15:0>: Analog Input Pin Configuration Control bits
123:                   1 = Analog input pin in Digital mode, port read input enabled, A/D input multiplexer input connected to AVSS
124:                   0 = Analog input pin in Analog mode, port read input disabled, A/D samples pin voltage */
125:                   ADPCFG = 0x0000; // all PORTB pins configured as analog
0011B4  EF22A8     CLR ADPCFG
126:                   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
127:                   /* bit 15 ADON: A/D Operating Mode bit
128:                   0,0,0,0|00,00,|111,0,|0,0,0,0
129:                   1 = A/D converter module is operating
130:                   *0 = A/D converter is off
131:                   bit 14 Unimplemented: Read as ?0?
132:                   bit 13 ADSIDL: Stop in Idle Mode bit
133:                   1 = Discontinue module operation when device enters Idle mode
134:                   *0 = Continue module operation in Idle mode
135:                   bit 12-10 Unimplemented: Read as ?0?
136:                   bit 9-8 FORM<1:0>: Data Output Format bits
137:                   11 = Signed fractional (DOUT = sddd dddd dddd 0000)
138:                   10 = Fractional (DOUT = dddd dddd dddd 0000)
139:                   01 = Signed integer (DOUT = ssss sddd dddd dddd)
140:                   *00 = Integer (DOUT = 0000 dddd dddd dddd)
141:                   bit 7-5 SSRC<2:0>: Conversion Trigger Source Select bits
142:                   *111 = Internal counter ends sampling and starts conversion (auto convert)
143:                   110 = Reserved
144:                   101 = Reserved
145:                   100 = Reserved
146:                   011 = Motor Control PWM interval ends sampling and starts conversion
147:                   010 = General purpose Timer3 compare ends sampling and starts conversion
148:                   001 = Active transition on INT0 pin ends sampling and starts conversion
149:                   000 = Clearing SAMP bit ends sampling and starts conversion
150:                   bit 4-3 Unimplemented: Read as ?0?
151:                   bit 2 ASAM: A/D Sample Auto-Start bit
152:                   1 = Sampling begins immediately after last conversion completes. SAMP bit is auto set.
153:                   *0 = Sampling begins when SAMP bit set
154:                   bit 1 SAMP: A/D Sample Enable bit
155:                   1 = At least one A/D sample/hold amplifier is sampling
156:                   *0 = A/D sample/hold amplifiers are holding
157:                   When ASAM = 0, writing ?1? to this bit will start sampling.
158:                   When SSRC = 000, writing ?0? to this bit will end sampling and start conversion.
159:                   bit 0 DONE: A/D Conversion Status bit
160:                   1 = A/D conversion is done
161:                   *0 = A/D conversion is not done
162:                   Clearing this bit will not effect any operation in progress.
163:                   Cleared by software or start of a new conversion. */
164:                   ADCON1 = 0x00E0; // SSRC bit = 111 implies internal
0011B6  200E00     MOV #0xE0, W0
0011B8  881500     MOV W0, ADCON1
165:                   // counter ends sampling and starts converting.
166:                   // Sampling begins when SAMP bit set
167:                   // Integer (DOUT = 0000 dddd dddd dddd)
168:                   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
169:                   /* bit 15-13 Unimplemented: Read as ?0?
170:                   bit 12 CH0NB: Channel 0 Negative Input Select for MUX B Multiplexer Setting bit
171:                   Same definition as bit <4> (see Note).
172:                   bit 11-8 CH0SB<3:0>: Channel 0 Positive Input Select for MUX B Multiplexer Setting bit
173:                   Same definition as bits <3:0> (see Note).
174:                   bit 7-5 Unimplemented: Read as ?0?
175:                   bit 4 CH0NA: Channel 0 Negative Input Select for MUX A Multiplexer Setting bit
176:                   1 = Channel 0 negative input is AN1
177:                   0 = Channel 0 negative input is VREFbit
178:                   3-0 CH0SA<3:0>: Channel 0 Positive Input Select for MUX A Multiplexer Setting bit
179:                   1111 = Channel 0 positive input is AN15
180:                   1110 = Channel 0 positive input is AN14
181:                   1101 = Channel 0 positive input is AN13
182:                   ·····
183:                   0001 = Channel 0 positive input is AN1
184:                   0000 = Channel 0 positive input is AN0 */
185:                   ADCHS = 0x0008; // Connect AN8/RB8 as CH0 input in first convertion cycle
0011BA  200080     MOV #0x8, W0
0011BC  881530     MOV W0, ADCHS
186:                   ////////////////////////////////////////////////////////////////////////////////////////////////////
187:                   ADCSSL = 0;
0011BE  EF22AA     CLR ADCSSL
188:                   /////////////////////////////////////////////////////////////////////////////////////////////
189:                   /* bit 15-13 Unimplemented: Read as ?0?
190:                   000,0|00010,|0,0,10|0110
191:                   bit 12-8 SAMC<4:0>: Auto Sample Time bits
192:                   11111 = 31 TAD
193:                   ·····
194:                   *00010 = 2 TAD
195:                   *00001 = 1 TAD
196:                   00000 = 0 TAD
197:                   bit 7 ADRC: A/D Conversion Clock Source bit
198:                   1 = A/D internal RC clock
199:                   *0 = Clock derived from system clock
200:                   bit 6 Unimplemented: Read as ?0?
201:                   bit 5-0 ADCS<5:0>: A/D Conversion Clock Select bits
202:                   111111 = TCY/2 ? (ADCS<5:0> + 1) = 32 ? TCY
203:                   ······
204:                   000001 = TCY/2 ? (ADCS<5:0> + 1) = TCY
205:                   000000 = TCY/2 ? (ADCS<5:0> + 1) = TCY/2 */
206:                   ADCON3 = 0x0226; // Sample time = 2Tad, Tad = 666.67 ns, ADCS = 2TAD/TCY - 1 = 2*666.67/33.9 - 1 = 38 = 100110
0011C0  202260     MOV #0x226, W0
0011C2  881520     MOV W0, ADCON3
207:                   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
208:                   /* bit 15-13 VCFG<2:0>: Voltage Reference Configuration bits
209:                   000,0,|0,0,00,|0,0,01|00,0,0
210:                    VCFG   |A/D VREFH          |A/D VREFL
211:                   ---------------------------------------------
212:                   000     |   AVDD            |   AVSS
213:                   001     |External VREF+ pin |AVSS
214:                   010     |AVDD               |External VREF- pin
215:                   011     |External VREF+ pin |External VREF- pin
216:                   1xx     |AVDD               |AVSS
217:                   ---------------------------------------------
218:                   bit 12 Reserved: User should write ?0? to this location
219:                   bit 11 Unimplemented: Read as ?0?
220:                   bit 10 CSCNA: Scan Input Selections for CH0+ S/H Input for MUX A Input Multiplexer Setting bit
221:                   1 = Scan inputs
222:                   0 = Do not scan inputs
223:                   bit 9-8 Unimplemented: Read as ?0?
224:                   bit 7 BUFS: Buffer Fill Status bit
225:                   Only valid when BUFM = 1 (ADRES split into 2 x 8-word buffers)
226:                   1 = A/D is currently filling buffer 0x8-0xF, user should access data in 0x0-0x7
227:                   0 = A/D is currently filling buffer 0x0-0x7, user should access data in 0x8-0xF
228:                   bit 6 Unimplemented: Read as ?0?
229:                   bit 5-2 SMPI<3:0>: Sample/Convert Sequences Per Interrupt Selection bits
230:                   1111 = Interrupts at the completion of conversion for each 16th sample/convert sequence
231:                   1110 = Interrupts at the completion of conversion for each 15th sample/convert sequence
232:                   .....
233:                   0001 = Interrupts at the completion of conversion for each 2nd sample/convert sequence
234:                   0000 = Interrupts at the completion of conversion for each sample/convert sequence
235:                   bit 1 BUFM: Buffer Mode Select bit
236:                   1 = Buffer configured as two 8-word buffers ADCBUF(15...8), ADCBUF(7...0)
237:                   0* = Buffer configured as one 16-word buffer ADCBUF(15...0)
238:                   bit 0 ALTS: Alternate Input Sample Mode Select bit
239:                   1 = Uses MUX A input multiplexer settings for first sample, then alternate between MUX B and MUX A input
240:                   multiplexer settings for all subsequent samples
241:                   0* = Always use MUX A input multiplexer settings */
242:                   ADCON2 = 0x0010; // Interrupt wil not be used anyway
0011C4  200100     MOV #0x10, W0
0011C6  881510     MOV W0, ADCON2
243:                   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
244:                   ADCON1bits.ADON = 1; // turn ADC ON
0011C8  A8E2A1     BSET 0x2A1, #7
245:               
246:                   ADC16Ptr = &ADCBUF0; // initialize ADCBUF pointer
0011CA  202800     MOV #0x280, W0
0011CC  884480     MOV W0, ADC16Ptr
247:                   IFS0bits.ADIF = 0; // clear ADC interrupt flag
0011CE  A96085     BCLR 0x85, #3
248:                   //ADCON1bits.ASAM = 1; // auto start sampling
249:                   // for 1Tad then go to conversion
250:                   //while (!IFS0bits.ADIF); // conversion done?
251:                   //ADCON1bits.ASAM = 0; // yes then stop sample/convert
252:                   ///for (count = 0; count < 16; count++) // average the 16 ADC value
253:                   //ADCValue = ADCValue + *ADC16Ptr++;
254:                   //ADCValue = ADCValue >> 4;
255:                   //} // repeat
256:               }
0011D0  FA8000     ULNK
0011D2  060000     RETURN
